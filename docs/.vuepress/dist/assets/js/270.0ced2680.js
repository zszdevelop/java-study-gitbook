(window.webpackJsonp=window.webpackJsonp||[]).push([[270],{1173:function(t,e,n){"use strict";n.r(e);var a=n(42),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"springboot-自动配置之-enable-与-import注解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#springboot-自动配置之-enable-与-import注解"}},[t._v("#")]),t._v(" SpringBoot 自动配置之@Enable*与@Import注解")]),t._v(" "),n("p",[t._v("SpringBoot 的自动配置非常强大，我们经常使用的"),n("code",[t._v("@Enable*")]),t._v("注解来开启对某方面的支持，那么"),n("code",[t._v("@Enable*")]),t._v(" 注解的原理是什么？")]),t._v(" "),n("h2",{attrs:{id:"_1-enable-注解与-import-注解之间的关系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-enable-注解与-import-注解之间的关系"}},[t._v("#")]),t._v(" 1. @Enable* 注解与 @Import 注解之间的关系")]),t._v(" "),n("p",[t._v("@Enable*举例")]),t._v(" "),n("ul",[n("li",[t._v("@EnableScheduling 开启计划任务的支持")]),t._v(" "),n("li",[t._v("@EnableAsync 开启异步方法的支持")])]),t._v(" "),n("p",[t._v("我们观察这些@Enable"),n("em",[t._v("源码可以看出，所有@Enable")]),t._v(" 注解都是有@Import的组合注解，@Enable* 自助开启的实现其实就是导入例如一些自动配置的bean")]),t._v(" "),n("p",[n("strong",[t._v("@Import 注解的最主要功能就是导入额外的配置信息")])]),t._v(" "),n("h2",{attrs:{id:"_2-import注解的用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-import注解的用法"}},[t._v("#")]),t._v(" 2. @Import注解的用法")]),t._v(" "),n("h3",{attrs:{id:"_2-1-方式一-直接导入配置类-configuration-类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-方式一-直接导入配置类-configuration-类"}},[t._v("#")]),t._v(" 2.1 方式一：直接导入配置类（@Configuration 类）")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Import(SchedulingConfiguration.class)\n@Documented\npublic @interface EnableScheduling {\n\n}\n")])])]),n("p",[t._v("可以看到EnableScheduling 注解直接导入配置类 SchedulingConfiguration，这个类注解了@Configuration，且注册了一个scheduledAnnotationProcessor的Bean，SchedulingConfiguration的源码如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("@Configuration\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\npublic class SchedulingConfiguration {\n\n\t@Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic ScheduledAnnotationBeanPostProcessor scheduledAnnotationProcessor() {\n\t\treturn new ScheduledAnnotationBeanPostProcessor();\n\t}\n\n}\n\n")])])]),n("h3",{attrs:{id:"_2-2-方式2-依据条件选择配置类-实现-importselector-接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-方式2-依据条件选择配置类-实现-importselector-接口"}},[t._v("#")]),t._v(" 2.2 方式2：依据条件选择配置类（实现 ImportSelector 接口）")]),t._v(" "),n("p",[t._v("如果并不确定引入哪个配置类，需要根据@Import注解所标识的类或者另一个注解（通常是注解）里的定义信息选择配置类的话，用这种方式。")]),t._v(" "),n("p",[t._v("ImportSelector接口只有一个方法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("String[] selectImports(AnnotationMetadata importingClassMetadata);\n")])])]),n("p",[t._v("AnnotationMetadata：用来获得当前配置类上的注解")]),t._v(" "),n("p",[t._v("例：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(AsyncConfigurationSelector.class)\npublic @interface EnableAsync {\n\n\tClass<? extends Annotation> annotation() default Annotation.class;\n\t\n\tboolean proxyTargetClass() default false;\n\n\tAdviceMode mode() default AdviceMode.PROXY;\n\n\tint order() default Ordered.LOWEST_PRECEDENCE;\n\n}\n\n")])])]),n("p",[t._v("AsyncConfigurationSelector继承AdviceModeImportSelector，AdviceModeImportSelector类实现ImportSelector接口 根据AdviceMode的不同来选择生明不同的Bean")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('public class AsyncConfigurationSelector extends AdviceModeImportSelector<EnableAsync> {\n\n\tprivate static final String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME =\n\t\t\t"org.springframework.scheduling.aspectj.AspectJAsyncConfiguration";\n\n\t@Override\n\t@Nullable\n\tpublic String[] selectImports(AdviceMode adviceMode) {\n\t\tswitch (adviceMode) {\n\t\t\tcase PROXY:\n\t\t\t\treturn new String[] {ProxyAsyncConfiguration.class.getName()};\n\t\t\tcase ASPECTJ:\n\t\t\t\treturn new String[] {ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME};\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n}\n\n\n')])])]),n("h2",{attrs:{id:"_2-3-方式3-动态注册bean-实现-importbeandefinitionregistrar-接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-方式3-动态注册bean-实现-importbeandefinitionregistrar-接口"}},[t._v("#")]),t._v(" 2.3 方式3：动态注册Bean（实现 ImportBeanDefinitionRegistrar 接口）")]),t._v(" "),n("p",[t._v("一般只要用户确切知道哪些Bean需要放入容器的话，自己可以通过spring 提供的注解来标识就可以了，比如@Component,@Service,@Repository,@Bean等。 如果是不确定的类，或者不是spring专用的，所以并不想用spring的注解进行侵入式标识，那么就可以通过@Import注解，实现ImportBeanDefinitionRegistrar接口来动态注册Bean。 比如：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(AspectJAutoProxyRegistrar.class)\npublic @interface EnableAspectJAutoProxy {\n\n\tboolean proxyTargetClass() default false;\n\t\n\tboolean exposeProxy() default false;\n\n}\n复制代码\n")])])]),n("p",[t._v("AspectJAutoProxyRegistrar实现了ImportBeanDefinitionRegistrar接口，ImportBeanDefinitionRegistrar的作用是在运行时自动添加Bean到已有的配置类，通过重写方法：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("public void registerBeanDefinitions(\n\t\t\tAnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);\n复制代码\n")])])]),n("ul",[n("li",[t._v("AnnotationMetadata  参数用来获得当前配置类上的注解")]),t._v(" "),n("li",[t._v("BeanDefinitionRegistry 参数用来注册Bean")])]),t._v(" "),n("p",[t._v("源码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('@Override\npublic void registerBeanDefinitions(\n\t\tAnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n\tAopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);\n\n\tAnnotationAttributes enableAspectJAutoProxy =\n\t\t\tAnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);\n\tif (enableAspectJAutoProxy != null) {\n\t\tif (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) {\n\t\t\tAopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);\n\t\t}\n\t\tif (enableAspectJAutoProxy.getBoolean("exposeProxy")) {\n\t\t\tAopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);\n\t\t}\n\t}\n}\n复制代码\n')])])]),n("h2",{attrs:{id:"参考文章"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/5c761c096fb9a049b41d2299",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring Boot 自动配置之@Enable* 与@Import注解"),n("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);