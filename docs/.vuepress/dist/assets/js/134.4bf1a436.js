(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{1120:function(_,t,a){"use strict";a.r(t);var v=a(42),s=Object(v.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"锁机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁机制"}},[_._v("#")]),_._v(" 锁机制")]),_._v(" "),v("h2",{attrs:{id:"_1-锁维度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-锁维度"}},[_._v("#")]),_._v(" 1. 锁维度")]),_._v(" "),v("p",[_._v("锁有好几种维度")]),_._v(" "),v("h3",{attrs:{id:"_1-1-类型维度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-类型维度"}},[_._v("#")]),_._v(" 1.1 类型维度")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("共享锁（读锁/S锁）")])]),_._v(" "),v("li",[v("p",[_._v("排他锁（写锁/X 锁）")]),_._v(" "),v("p",[_._v("类型细分")]),_._v(" "),v("ul",[v("li",[_._v("意向共享锁")]),_._v(" "),v("li",[_._v("意向排他（互斥）锁")])])]),_._v(" "),v("li",[v("p",[_._v("悲观锁（使用锁，既for update）")])]),_._v(" "),v("li",[v("p",[_._v("乐观锁（使用版本号字段，类似 CAS 机制，既用户自己控制。缺点：并发很高的时候，多了很多无用的重试）")])])]),_._v(" "),v("h3",{attrs:{id:"_1-2-锁的粒度-粒度维度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-锁的粒度-粒度维度"}},[_._v("#")]),_._v(" 1.2 锁的粒度（粒度维度）")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("表锁")])]),_._v(" "),v("li",[v("p",[_._v("页锁（Mysql BerkeleyDB 引擎）")])]),_._v(" "),v("li",[v("p",[_._v("行锁（InnoDB）")]),_._v(" "),v("p",[_._v("行锁的实现原理就是锁住聚集索引，如果你查询的时候，没有正确地击中索引，MySql 优化器将会抛弃行锁，使用表锁。")])])]),_._v(" "),v("h3",{attrs:{id:"_1-3-锁的算法-算法维度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-锁的算法-算法维度"}},[_._v("#")]),_._v(" 1.3 锁的算法（算法维度）")]),_._v(" "),v("ul",[v("li",[_._v("Record Lock（单行记录）")]),_._v(" "),v("li",[_._v("Gap Lock（间隙锁，锁定一个范围，但不包含锁定记录）")]),_._v(" "),v("li",[_._v("Next-key Lock（Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身。MySQL 防止幻读，就是使用此锁实现）")])]),_._v(" "),v("h2",{attrs:{id:"_2-默认的读操作-上锁吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-默认的读操作-上锁吗"}},[_._v("#")]),_._v(" 2. 默认的读操作，上锁吗？")]),_._v(" "),v("p",[_._v("默认是MVCC机制（“一致性非锁定读”）保证RR 级别的隔离正确性。是不上锁的")]),_._v(" "),v("p",[_._v("可以选择手动上锁")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("排他锁：select xxxx for update")])]),_._v(" "),v("li",[v("p",[_._v("共享锁：select xxx lock in share mode")]),_._v(" "),v("p",[_._v("称为一致性锁定读")])])]),_._v(" "),v("p",[_._v("使用锁之后，就能在RR 级别下，避免幻读。当然默认的MVCC读，也能避免幻读")]),_._v(" "),v("h2",{attrs:{id:"_3-mysql-的-serializable-有啥用呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-mysql-的-serializable-有啥用呢"}},[_._v("#")]),_._v(" 3 MySQL 的 SERIALIZABLE 有啥用呢？")]),_._v(" "),v("p",[_._v("MySQL RR能够防止幻读,那么，SERIALIZABLE 有啥用呢？")]),_._v(" "),v("p",[_._v("他可以"),v("strong",[_._v("防止丢失更新")])]),_._v(" "),v("p",[v("img",{attrs:{src:a(495),alt:"image-20190912235538188"}})]),_._v(" "),v("p",[_._v("这个时候，我们必须使用SERIALIZABLE 级别进行串行读取。")])])}),[],!1,null,null,null);t.default=s.exports},495:function(_,t,a){_.exports=a.p+"assets/img/image-20190912235538188.e4030e85.png"}}]);