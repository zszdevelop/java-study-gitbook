(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{1176:function(a,_,t){"use strict";t.r(_);var e=t(42),v=Object(e.a)({},(function(){var a=this,_=a.$createElement,e=a._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"联合索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#联合索引"}},[a._v("#")]),a._v(" 联合索引")]),a._v(" "),e("h2",{attrs:{id:"_1-什么是联合索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是联合索引"}},[a._v("#")]),a._v(" 1. 什么是联合索引")]),a._v(" "),e("p",[a._v("两个或更多个列上的索引被称为联合索引，联合索引又叫复合索引。")]),a._v(" "),e("p",[a._v("对于联合索引：")]),a._v(" "),e("ul",[e("li",[a._v("MySql从左到右使用索引中字段")]),a._v(" "),e("li",[a._v("一个查询可以只使用索引中的一部分，但只能是最左部分（最左前缀）")])]),a._v(" "),e("p",[a._v("例如：")]),a._v(" "),e("p",[a._v("索引是key index（a,b,c） 可以支持"),e("strong",[a._v("a|a,b|a,b,c")]),a._v("，三种组合查找，但不支持b,c 进行查找。当最左侧字段是常量引用时，索引就十分有效")]),a._v(" "),e("h2",{attrs:{id:"_2-需要遵循的规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-需要遵循的规则"}},[a._v("#")]),a._v(" 2. 需要遵循的规则")]),a._v(" "),e("ol",[e("li",[a._v("需要加索引的字段，要在where条件中")]),a._v(" "),e("li",[a._v("数据量少的字段不需要加索引")]),a._v(" "),e("li",[a._v("如何where条件中是or关系，加索引不起作用")]),a._v(" "),e("li",[a._v("符合最左前缀原则")])]),a._v(" "),e("h2",{attrs:{id:"_3-原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-原理"}},[a._v("#")]),a._v(" 3. 原理")]),a._v(" "),e("h3",{attrs:{id:"_3-1-b-tree结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-b-tree结构"}},[a._v("#")]),a._v(" 3.1 B+Tree结构")]),a._v(" "),e("p",[a._v("每一个磁盘快在mysql中是一个页，页大小是固定的，mysql innodb的默认的页大小是16k。每个索引会分配在页上的数量是由字段的大小决定。当字段值长度越长，每一页上的数量就会越少，因此在一定数据量的情况下，所以的深度会越深，影响索引查找效率")]),a._v(" "),e("p",[e("img",{attrs:{src:t(553),alt:"image-20190909223519018"}})]),a._v(" "),e("p",[a._v("对于复合索引（多列b+tree,使用多列值组合而成的b+tree索引）。遵循最左前缀原则，从左到右的使用索引中的字段，"),e("strong",[a._v("一个查询可以只使用索引中的一部分，但只能是做左侧部分")])]),a._v(" "),e("h3",{attrs:{id:"_3-2-实例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-实例"}},[a._v("#")]),a._v(" 3.2 实例")]),a._v(" "),e("p",[a._v("创建表test")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("create table test(\n\na int,\n\nb int,\n\nc int,\n\nKEY a(a,b,c)\n\n);\n")])])]),e("p",[a._v("比如（a,b,c）的时候，b+tree是按照从"),e("strong",[a._v("左到右的顺序来建立搜索树")]),a._v("的")]),a._v(" "),e("ul",[e("li",[a._v("当（a =? and b= ? and c=?) 这样的数据来检索的时候\n"),e("ul",[e("li",[a._v("b+树会优先比较a列来确定下一步的方向")]),a._v(" "),e("li",[a._v("如果a列相同再依次比较b列和c列")]),a._v(" "),e("li",[a._v("最后得到检索数据")])])]),a._v(" "),e("li",[a._v("但当（b=? and c =?）这样没有a列的数据来的时候\n"),e("ul",[e("li",[a._v("b+树就不知道下一步该查那个节点，因为建立搜索树的时候a列就是第一个比较因子。必须要先跟a列来搜索才能知道下一步去哪里查询")])])]),a._v(" "),e("li",[a._v("当（a=? and c =?）这样的数据来检索时\n"),e("ul",[e("li",[a._v("b+树可以用a列来制定搜索方向，但下一个字段b列的缺失，只能吧a列的数据找到")]),a._v(" "),e("li",[a._v("然后在匹配c列的数据")])])])]),a._v(" "),e("h2",{attrs:{id:"_4-多列索引的应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-多列索引的应用"}},[a._v("#")]),a._v(" 4. 多列索引的应用")]),a._v(" "),e("h3",{attrs:{id:"_4-1-多列索引在and查询中的应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-多列索引在and查询中的应用"}},[a._v("#")]),a._v(" 4.1 多列索引在and查询中的应用")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("select * from test where a=? and b=? and c=?；")]),a._v(" "),e("p",[a._v("查询效率最高，索引全覆盖。")])]),a._v(" "),e("li",[e("p",[a._v("select * from test where a=? and b=?")]),a._v(" "),e("p",[a._v("索引覆盖a和b。")])]),a._v(" "),e("li",[e("p",[a._v("select * from test where b=? and a=?")]),a._v(" "),e("p",[a._v("经过mysql的查"),e("strong",[a._v("询分析器的优化，索引覆盖a和b")]),a._v("。")])]),a._v(" "),e("li",[e("p",[a._v("select * from test where a=?；")]),a._v(" "),e("p",[a._v("索引覆盖a。")])]),a._v(" "),e("li",[e("p",[a._v("select * from test where b=? and c=?")]),a._v(" "),e("p",[a._v("没有a列，不走索引，索引失效。")])]),a._v(" "),e("li",[e("p",[a._v("select * from test where c=?；")]),a._v(" "),e("p",[a._v("没有a列，不走索引，索引失效。")])])]),a._v(" "),e("h3",{attrs:{id:"_4-2-多列索引在范围查询中应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-多列索引在范围查询中应用"}},[a._v("#")]),a._v(" 4.2 多列索引在范围查询中应用")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("select * from test where a=? and b between ? and ? and c=?；")]),a._v(" "),e("p",[a._v("索引覆盖a和b，"),e("strong",[a._v("因b列是范围查询，因此c列不能走索引")]),a._v("。")])]),a._v(" "),e("li",[e("p",[a._v("select * from test where a between ? and ? and b=?；")]),a._v(" "),e("p",[a._v("a列走索引，因a列是范围查询，因此b列是无法使用索引。")])]),a._v(" "),e("li",[e("p",[a._v("select * from test where a between ? and ? and b between ? and ? and c=?；")]),a._v(" "),e("p",[a._v("a列走索引，因a列是范围查询，b列是范围查询也不能使用索引。")])])]),a._v(" "),e("h3",{attrs:{id:"_4-3-多列索引在排序中应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-多列索引在排序中应用"}},[a._v("#")]),a._v(" 4.3 "),e("strong",[a._v("多列索引在排序中应用")])]),a._v(" "),e("ul",[e("li",[e("p",[a._v("select * from test where a=? and b=? order by c；")]),a._v(" "),e("p",[a._v("a、b、c三列全覆盖索引，查询效率最高。")])]),a._v(" "),e("li",[e("p",[a._v("select * from test where a=? and b between ? and ? order by c；")]),a._v(" "),e("p",[a._v("a、b列使用索引查找，因b列是范围查询，因此c列不能使用索引，会出现file sort。")])])]),a._v(" "),e("h2",{attrs:{id:"_5-总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-总结"}},[a._v("#")]),a._v(" 5. 总结")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("联合索引的使用在写where调的顺序无关，mysql 查询分析会进行优化而使用索引，但是为了减轻查询分析器的压力，最好和索引的从左到右的顺序一致")])]),a._v(" "),e("li",[e("p",[a._v("使用等值查询，多列同时查询，索引会一直传递并生效。因此等值查询效率最好。")])]),a._v(" "),e("li",[e("p",[a._v("索引查找遵循最左侧原则。"),e("strong",[a._v("但是遇到范围查询列之后的列索引失效。")])])]),a._v(" "),e("li",[e("p",[a._v("排序也能使用索引，合理使用索引排序，避免出现file sort。")])])])])}),[],!1,null,null,null);_.default=v.exports},553:function(a,_,t){a.exports=t.p+"assets/img/image-20190909223519018.bf936230.png"}}]);