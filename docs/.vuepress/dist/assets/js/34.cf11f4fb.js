(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{1128:function(a,t,e){"use strict";e.r(t);var n=e(42),s=Object(n.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"如何发现、预防、解决死锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何发现、预防、解决死锁"}},[a._v("#")]),a._v(" 如何发现、预防、解决死锁")]),a._v(" "),n("h2",{attrs:{id:"_1-死锁的定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-死锁的定义"}},[a._v("#")]),a._v(" 1. 死锁的定义")]),a._v(" "),n("p",[a._v("“死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。”")]),a._v(" "),n("p",[a._v("竞争的资源可以是：锁、网络连接、通知事件，磁盘、带宽，以及一切可以被称作“资源”的东西。")]),a._v(" "),n("h2",{attrs:{id:"_2-举例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-举例"}},[a._v("#")]),a._v(" 2. 举例")]),a._v(" "),n("p",[a._v("如果此时有一个线程A，按照先锁a再获得锁b的顺序获得锁，而在此时又有一个线程B，按照先锁b再锁a的顺序获得锁")]),a._v(" "),n("p",[n("img",{attrs:{src:e(468),alt:"image-20200311231729573"}})]),a._v(" "),n("p",[a._v("我们可以用一段代码来表示：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('public static void main(String[] args) {\n    final Object a = new Object();\n    final Object b = new Object();\n    Thread threadA = new Thread(new Runnable() {\n        public void run() {\n            synchronized (a) {\n                try {\n                    System.out.println("now i in threadA-locka");\n                    Thread.sleep(1000l);\n                    synchronized (b) {\n                        System.out.println("now i in threadA-lockb");\n                    }\n                } catch (Exception e) {\n                    // ignore\n                }\n            }\n        }\n    });\n\n    Thread threadB = new Thread(new Runnable() {\n        public void run() {\n            synchronized (b) {\n                try {\n                    System.out.println("now i in threadB-lockb");\n                    Thread.sleep(1000l);\n                    synchronized (a) {\n                        System.out.println("now i in threadB-locka");\n                    }\n                } catch (Exception e) {\n                    // ignore\n                }\n            }\n        }\n    });\n\n    threadA.start();\n    threadB.start();\n}\n\n')])])]),n("p",[a._v("我们可以看到执行结果如下：")]),a._v(" "),n("p",[n("img",{attrs:{src:e(469),alt:"image-20200311232054845"}})]),a._v(" "),n("p",[a._v("很明显，程序执行停滞了")]),a._v(" "),n("h2",{attrs:{id:"_2-死锁检测"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-死锁检测"}},[a._v("#")]),a._v(" 2. 死锁检测")]),a._v(" "),n("p",[a._v("主要介绍两种死锁检查工具")]),a._v(" "),n("h2",{attrs:{id:"_2-1-jstack命令"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-jstack命令"}},[a._v("#")]),a._v(" 2.1 Jstack命令")]),a._v(" "),n("p",[a._v("Jstack 是java 虚拟机自带的一种堆栈跟踪工具。jstack 用于"),n("strong",[a._v("打印")]),a._v("出给定的java 进程ID或core file 或远程调试服务的"),n("strong",[a._v("java堆栈信息")]),a._v("。Jstack工具可以用于生成Java虚拟机当前时刻的线程快照，"),n("strong",[a._v("线程快照")]),a._v("是当前java虚拟机内每一条线程"),n("strong",[a._v("正在执行")]),a._v("的"),n("strong",[a._v("方法堆栈")]),a._v("的集合，生成线程快照的主要目的是定位线程出现长时间停顿原因，如"),n("code",[a._v("线程间死锁")]),a._v("、"),n("code",[a._v("死循环")]),a._v("、"),n("code",[a._v("请求外部资源导致的长时间等待")]),a._v("等。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有相应的线程到底在后台做了什么事情，或者等待什么资源")]),a._v(" "),n("p",[a._v("首先，我们通过jps确定当前执行任务的进程号:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("jonny@~$ jps\n597\n1370 JConsole\n1362 AppMain\n1421 Jps\n1361 Launcher\n")])])]),n("p",[a._v("可以确定任务进程号1362，然后执行jstack命令查看当前进程堆栈信息：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('jonny@~$ jstack -F 1362\nAttaching to process ID 1362, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 23.21-b01\nDeadlock Detection:\n\nFound one Java-level deadlock:\n=============================\n\n"Thread-1":\n  waiting to lock Monitor@0x00007fea1900f6b8 (Object@0x00000007efa684c8, a java/lang/Object),\n  which is held by "Thread-0"\n"Thread-0":\n  waiting to lock Monitor@0x00007fea1900ceb0 (Object@0x00000007efa684d8, a java/lang/Object),\n  which is held by "Thread-1"\n\nFound a total of 1 deadlock.\n\n')])])]),n("p",[a._v("可以看到，进程的确存在死锁，两个线程分别在等待对方持有的Object对象")]),a._v(" "),n("h3",{attrs:{id:"_2-2-jconsole-工具"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-jconsole-工具"}},[a._v("#")]),a._v(" 2.2 JConsole 工具")]),a._v(" "),n("p",[a._v("Jconsole 是 Jdk自带的监控工具，在Jdk/bin 目录下可以找到，他用户连接正在运行的本地或者远程的JVM，对运行在Java 应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小")]),a._v(" "),n("p",[a._v("我们在命令行中敲入jconsole命令，会自动弹出以下对话框，选择进程1362，并点击“"),n("strong",[a._v("链接")]),a._v("”")]),a._v(" "),n("p",[n("img",{attrs:{src:e(470),alt:"image-20200311234432625"}})]),a._v(" "),n("p",[a._v("进入锁检查的进程后，选择“线程”选项卡，并点击“检查死锁”")]),a._v(" "),n("p",[n("img",{attrs:{src:e(471),alt:"image-20200311234702867"}})]),a._v(" "),n("p",[a._v("我们可以看到")]),a._v(" "),n("p",[n("img",{attrs:{src:e(472),alt:"image-20200311234651568"}})]),a._v(" "),n("p",[a._v("可以看到进程中存在死锁")]),a._v(" "),n("h2",{attrs:{id:"_2-预防与解决死锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-预防与解决死锁"}},[a._v("#")]),a._v(" 2. 预防与解决死锁")]),a._v(" "),n("p",[a._v("破坏死锁产生的四个必要条件")]),a._v(" "),n("h3",{attrs:{id:"_2-1-破坏互斥条件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-破坏互斥条件"}},[a._v("#")]),a._v(" 2.1 破坏互斥条件")]),a._v(" "),n("p",[a._v("这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）")]),a._v(" "),n("h3",{attrs:{id:"_2-2-破坏请求与保持条件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-破坏请求与保持条件"}},[a._v("#")]),a._v(" 2.2 破坏请求与保持条件")]),a._v(" "),n("p",[a._v("一次性申请所有的资源")]),a._v(" "),n("h3",{attrs:{id:"_2-3-破坏不可剥夺条件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-破坏不可剥夺条件"}},[a._v("#")]),a._v(" 2.3 破坏不可剥夺条件")]),a._v(" "),n("p",[a._v("占用部分资源的线程进一步申请其他资源时，如果申请不到，可以"),n("strong",[a._v("主动释放他占有的资源")])]),a._v(" "),n("h3",{attrs:{id:"_2-4-破坏循环等待条件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-破坏循环等待条件"}},[a._v("#")]),a._v(" 2.4 破坏循环等待条件")]),a._v(" "),n("p",[a._v("靠按顺序申请资源来预防，按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件")])])}),[],!1,null,null,null);t.default=s.exports},468:function(a,t,e){a.exports=e.p+"assets/img/image-20200311231729573.fee5b228.png"},469:function(a,t,e){a.exports=e.p+"assets/img/image-20200311232054845.010d43b3.png"},470:function(a,t,e){a.exports=e.p+"assets/img/image-20200311234432625.8041c449.png"},471:function(a,t,e){a.exports=e.p+"assets/img/image-20200311234702867.bef1f5cf.png"},472:function(a,t,e){a.exports=e.p+"assets/img/image-20200311234651568.37e2ac0b.png"}}]);