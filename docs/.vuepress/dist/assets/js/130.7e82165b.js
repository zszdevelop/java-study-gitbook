(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{1072:function(_,v,a){"use strict";a.r(v);var t=a(42),s=Object(t.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"类加载过程-精简版"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程-精简版"}},[_._v("#")]),_._v(" 类加载过程(精简版)")]),_._v(" "),t("h1",{attrs:{id:"_1-前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-前言"}},[_._v("#")]),_._v(" 1. 前言")]),_._v(" "),t("p",[_._v("一个java文件从编码完成到最终执行，一般主要包含两个过程")]),_._v(" "),t("ul",[t("li",[_._v("编译")]),_._v(" "),t("li",[_._v("运行")])]),_._v(" "),t("p",[t("strong",[_._v("编译")]),_._v("，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。")]),_._v(" "),t("p",[t("strong",[_._v("运行")]),_._v("，则是把编译生成的.class文件交给Java虚拟机(JVM)执行。")]),_._v(" "),t("p",[_._v("而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。")]),_._v(" "),t("p",[_._v("举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。")]),_._v(" "),t("p",[_._v("由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且"),t("strong",[_._v("只加载一次")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"_2-类加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-类加载"}},[_._v("#")]),_._v(" 2. 类加载")]),_._v(" "),t("p",[_._v("类加载的过程主要分为三个部分：")]),_._v(" "),t("ul",[t("li",[_._v("加载")]),_._v(" "),t("li",[_._v("链接")]),_._v(" "),t("li",[_._v("初始化")])]),_._v(" "),t("p",[_._v("而链接又可以细分为三个小部分：")]),_._v(" "),t("ul",[t("li",[_._v("验证")]),_._v(" "),t("li",[_._v("准备")]),_._v(" "),t("li",[_._v("解析")])]),_._v(" "),t("p",[t("img",{attrs:{src:a(427),alt:"image-20190928231926138"}})]),_._v(" "),t("h3",{attrs:{id:"_2-1-加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-加载"}},[_._v("#")]),_._v(" 2.1 加载")]),_._v(" "),t("p",[_._v("简单来说，加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。")]),_._v(" "),t("p",[_._v("这里有两个重点：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("字节码来源")]),_._v("。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译")]),_._v(" "),t("li",[t("strong",[_._v("类加载器")]),_._v("。一般包括"),t("strong",[_._v("启动类加载器")]),_._v("，"),t("strong",[_._v("扩展类加载器")]),_._v("，"),t("strong",[_._v("应用类加载器")]),_._v("，以及用户的"),t("strong",[_._v("自定义类加载器")]),_._v("。")])]),_._v(" "),t("p",[t("strong",[_._v("注：为什么会有自定义类加载器？")])]),_._v(" "),t("ul",[t("li",[_._v("一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。")]),_._v(" "),t("li",[_._v("另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。")])]),_._v(" "),t("h3",{attrs:{id:"_2-2-链接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-链接"}},[_._v("#")]),_._v(" 2.2 链接")]),_._v(" "),t("h4",{attrs:{id:"_2-2-1-验证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-验证"}},[_._v("#")]),_._v(" 2.2.1 验证")]),_._v(" "),t("p",[_._v("主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。")]),_._v(" "),t("p",[_._v("包括对于"),t("strong",[_._v("文件格式的验证")]),_._v("，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？")]),_._v(" "),t("p",[_._v("对于"),t("strong",[_._v("元数据的验证")]),_._v("，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？")]),_._v(" "),t("p",[_._v("对于"),t("strong",[_._v("字节码的验证")]),_._v("，保证程序语义的合理性，比如要保证类型转换的合理性。")]),_._v(" "),t("p",[_._v("对于"),t("strong",[_._v("符号引用的验证")]),_._v("，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？")]),_._v(" "),t("h4",{attrs:{id:"_2-2-2-准备"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-准备"}},[_._v("#")]),_._v(" 2.2.2 准备")]),_._v(" "),t("p",[_._v("主要是为类变量（注意，不是实例变量）分配内存，并且赋予"),t("strong",[_._v("初值")]),_._v("。")]),_._v(" "),t("p",[_._v("特别需要注意，"),t("strong",[_._v("初值，不是代码中具体写的初始化的值")]),_._v("，而是Java虚拟机根据不同变量类型的默认初始值。")]),_._v(" "),t("p",[_._v("比如8种"),t("strong",[_._v("基本类型")]),_._v("的初值，默认为0；"),t("strong",[_._v("引用类型")]),_._v("的初值则为null；"),t("strong",[_._v("常量")]),_._v("的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456")]),_._v(" "),t("h3",{attrs:{id:"_2-2-3-解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-解析"}},[_._v("#")]),_._v(" 2.2.3 解析")]),_._v(" "),t("p",[_._v("将常量池内的符号引用替换为直接引用的过程。")]),_._v(" "),t("p",[_._v("两个重点：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("符号引用")]),_._v("。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。")]),_._v(" "),t("li",[t("strong",[_._v("直接引用")]),_._v("。可以理解为一个内存地址，或者一个偏移量。比如"),t("strong",[_._v("类方法，类变量")]),_._v("的直接引用是指向方法区的"),t("strong",[_._v("指针")]),_._v("；而"),t("strong",[_._v("实例方法，实例变量")]),_._v("的直接引用则是从实例的头指针开始算起到这个实例变量位置的"),t("strong",[_._v("偏移量")])])]),_._v(" "),t("p",[_._v("举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。")]),_._v(" "),t("p",[_._v("在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。")]),_._v(" "),t("h3",{attrs:{id:"_2-3-初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-初始化"}},[_._v("#")]),_._v(" 2.3 初始化")]),_._v(" "),t("p",[_._v("这个阶段主要是对"),t("strong",[_._v("类变量")]),_._v("初始化，是执行类构造器的过程。")]),_._v(" "),t("p",[_._v("换句话说，只对static修饰的变量或语句进行初始化。")]),_._v(" "),t("p",[_._v("如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。")]),_._v(" "),t("p",[_._v("如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。")]),_._v(" "),t("h2",{attrs:{id:"_3-总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-总结"}},[_._v("#")]),_._v(" 3. 总结")]),_._v(" "),t("p",[_._v("类加载过程只是一个类生命周期的一部分，在其前，有编译的过程，只有对源代码编译之后，才能获得能够被虚拟机加载的字节码文件；在其后还有具体的类使用过程，当使用完成之后，还会在方法区垃圾回收的过程中进行卸载。")]),_._v(" "),t("p",[t("strong",[_._v("相关扩展知识点：")])]),_._v(" "),t("ul",[t("li",[_._v("Java虚拟机的基本机构？")]),_._v(" "),t("li",[_._v("什么是类加载器？")]),_._v(" "),t("li",[_._v("简单谈一下类加载的双亲委托机制？")]),_._v(" "),t("li",[_._v("普通Java类的类加载过程和Tomcat的类加载过程是否一样？区别在哪？")]),_._v(" "),t("li",[_._v("简单谈一下Java堆的垃圾回收机制？")])]),_._v(" "),t("h3",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[_._v("#")]),_._v(" 参考文章")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/33509426?utm_source=wechat_session&utm_medium=social&utm_oi=52825262391296",target:"_blank",rel:"noopener noreferrer"}},[_._v("面试官：请你谈谈Java的类加载过程"),t("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=s.exports},427:function(_,v,a){_.exports=a.p+"assets/img/image-20190928231926138.5ade93a0.png"}}]);