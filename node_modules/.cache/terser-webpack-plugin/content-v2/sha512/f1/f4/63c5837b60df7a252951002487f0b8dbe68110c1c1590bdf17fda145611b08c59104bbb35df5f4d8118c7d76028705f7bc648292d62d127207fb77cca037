{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[246],{1118:function(_,v,l){\"use strict\";l.r(v);var t=l(42),i=Object(t.a)({},(function(){var _=this,v=_.$createElement,l=_._self._c||v;return l(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":_.$parent.slotKey}},[l(\"h1\",{attrs:{id:\"锁机制锁\"}},[l(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#锁机制锁\"}},[_._v(\"#\")]),_._v(\" 锁机制锁\")]),_._v(\" \"),l(\"h2\",{attrs:{id:\"_1-myisam-和innodb-存储引擎使用的锁\"}},[l(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-myisam-和innodb-存储引擎使用的锁\"}},[_._v(\"#\")]),_._v(\" 1. MyISAM 和InnoDB 存储引擎使用的锁\")]),_._v(\" \"),l(\"ul\",[l(\"li\",[_._v(\"MyISAM 采用的是表级锁（table-level locking）\")]),_._v(\" \"),l(\"li\",[_._v(\"InnoDB 支持行级锁（row-level locking）和表级锁，默认行为是行级锁\")])]),_._v(\" \"),l(\"h2\",{attrs:{id:\"_2-表级锁和行级锁对比\"}},[l(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-表级锁和行级锁对比\"}},[_._v(\"#\")]),_._v(\" 2.表级锁和行级锁对比\")]),_._v(\" \"),l(\"ul\",[l(\"li\",[l(\"p\",[_._v(\"表级锁\")]),_._v(\" \"),l(\"p\",[_._v(\"MySQL 中锁定 \"),l(\"strong\",[_._v(\"粒度最大\")]),_._v(\"的一种锁，对当前\"),l(\"strong\",[_._v(\"操作的整张表加锁\")])]),_._v(\" \"),l(\"ul\",[l(\"li\",[_._v(\"优势\\n\"),l(\"ul\",[l(\"li\",[_._v(\"实现简单，资源消耗少，加锁快\")]),_._v(\" \"),l(\"li\",[_._v(\"不会出现死锁\")])])]),_._v(\" \"),l(\"li\",[_._v(\"缺点\\n\"),l(\"ul\",[l(\"li\",[_._v(\"其锁粒度最大，触发锁冲突的概率最高\")]),_._v(\" \"),l(\"li\",[_._v(\"并发度最低\")])])])])]),_._v(\" \"),l(\"li\",[l(\"p\",[_._v(\"行级锁\")]),_._v(\" \"),l(\"p\",[_._v(\"MySQL 中锁定 \"),l(\"strong\",[_._v(\"粒度最小\")]),_._v(\"的一种锁，只针对当前\"),l(\"strong\",[_._v(\"操作的行加锁\")])]),_._v(\" \"),l(\"ul\",[l(\"li\",[_._v(\"优势\")]),_._v(\" \"),l(\"li\",[_._v(\"大大减少数据库操作的冲突\")]),_._v(\" \"),l(\"li\",[_._v(\"加锁粒度小，并发度高\")]),_._v(\" \"),l(\"li\",[_._v(\"缺点\\n\"),l(\"ul\",[l(\"li\",[_._v(\"加锁的开销大\")]),_._v(\" \"),l(\"li\",[_._v(\"加锁慢\")]),_._v(\" \"),l(\"li\",[_._v(\"会出现死锁\")])])])])])]),_._v(\" \"),l(\"h2\",{attrs:{id:\"_3-innodb存储引擎的锁算法\"}},[l(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-innodb存储引擎的锁算法\"}},[_._v(\"#\")]),_._v(\" 3. InnoDB存储引擎的锁算法\")]),_._v(\" \"),l(\"ul\",[l(\"li\",[_._v(\"Record lock：单个行记录上的锁\")]),_._v(\" \"),l(\"li\",[_._v(\"Gap lock: 间隙锁，锁定一个范围，不包括记录本身\")]),_._v(\" \"),l(\"li\",[l(\"strong\",[_._v(\"Next-key lock: record+gap 锁定一个锁范围，包含记录本身\")])])]),_._v(\" \"),l(\"h3\",{attrs:{id:\"_3-1-相关知识点\"}},[l(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-1-相关知识点\"}},[_._v(\"#\")]),_._v(\" 3.1 相关知识点\")]),_._v(\" \"),l(\"ol\",[l(\"li\",[_._v(\"innodb 对于行的查询使用next-key lock\")]),_._v(\" \"),l(\"li\",[_._v(\"next-locking keying 为了解决Phantom Problem幻读问题\")]),_._v(\" \"),l(\"li\",[_._v(\"当查询的索引含有唯一属性时，将next-key lock降级为 record key\")]),_._v(\" \"),l(\"li\",[_._v(\"Gap 锁设计的目的是为了阻止多个事务将记录插入到同一范围内，这会导致幻读问题的产生\")]),_._v(\" \"),l(\"li\",[_._v(\"有两种方式显示关闭gap 锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock）\\n\"),l(\"ol\",[l(\"li\",[_._v(\"将事务隔离级别设置为READ-COMMITTED\")]),_._v(\" \"),l(\"li\",[_._v(\"将参数innodb_locks_unsafe_for_binlog 设置为1\")])])])])])}),[],!1,null,null,null);v.default=i.exports}}]);","extractedComments":[]}