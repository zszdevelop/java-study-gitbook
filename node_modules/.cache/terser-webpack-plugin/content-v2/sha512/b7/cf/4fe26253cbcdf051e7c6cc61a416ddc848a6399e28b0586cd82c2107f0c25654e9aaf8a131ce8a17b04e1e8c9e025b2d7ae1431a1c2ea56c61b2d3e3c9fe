{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{1035:function(t,a,s){\"use strict\";s.r(a);var r=s(42),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"垃圾收集器垃圾收集算法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#垃圾收集器垃圾收集算法\"}},[t._v(\"#\")]),t._v(\" 垃圾收集器垃圾收集算法\")]),t._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:s(412),alt:\"image-20190925225149527\"}})]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_1-标记-清除算法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-标记-清除算法\"}},[t._v(\"#\")]),t._v(\" 1. 标记-清除算法\")]),t._v(\" \"),r(\"p\",[t._v(\"该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：\")]),t._v(\" \"),r(\"ol\",[r(\"li\",[r(\"strong\",[t._v(\"效率问题\")])]),t._v(\" \"),r(\"li\",[r(\"strong\",[t._v(\"空间问题（标记清除后会产生大量不连续的碎片）\")])])]),t._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:s(413),alt:\"image-20190925225333900\"}})]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_2-复制算法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-复制算法\"}},[t._v(\"#\")]),t._v(\" 2. 复制算法\")]),t._v(\" \"),r(\"p\",[t._v(\"为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\")]),t._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:s(414),alt:\"image-20190925225448917\"}})]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_3-标记-整理算法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-标记-整理算法\"}},[t._v(\"#\")]),t._v(\" 3. 标记-整理算法\")]),t._v(\" \"),r(\"p\",[t._v(\"根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\")]),t._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:s(415),alt:\"image-20190925225549662\"}})]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_4-分代收集算法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-分代收集算法\"}},[t._v(\"#\")]),t._v(\" 4. 分代收集算法\")]),t._v(\" \"),r(\"p\",[t._v(\"当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\")]),t._v(\" \"),r(\"p\",[r(\"strong\",[t._v(\"比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\")])]),t._v(\" \"),r(\"p\",[r(\"strong\",[t._v(\"延伸面试问题：\")]),t._v(\" HotSpot 为什么要分为新生代和老年代？\")])])}),[],!1,null,null,null);a.default=e.exports},412:function(t,a,s){t.exports=s.p+\"assets/img/image-20190925225149527.de319917.png\"},413:function(t,a,s){t.exports=s.p+\"assets/img/image-20190925225333900.b41632d7.png\"},414:function(t,a,s){t.exports=s.p+\"assets/img/image-20190925225448917.61246124.png\"},415:function(t,a,s){t.exports=s.p+\"assets/img/image-20190925225549662.74d1d166.png\"}}]);","extractedComments":[]}