{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{1106:function(e,a,t){\"use strict\";t.r(a);var s=t(42),i=Object(s.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[s(\"h1\",{attrs:{id:\"shallow-heap和retained-heap\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#shallow-heap和retained-heap\"}},[e._v(\"#\")]),e._v(\" Shallow heap和Retained heap\")]),e._v(\" \"),s(\"p\",[e._v(\"所有包含Heap Proflin 功能的工具（MAT，TPTP等）都会使用到两个名词，一个是Shallow Size，另一个是Retained Size\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"_1-概念\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-概念\"}},[e._v(\"#\")]),e._v(\" 1 概念\")]),e._v(\" \"),s(\"h3\",{attrs:{id:\"_1-1-shallow-size\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-1-shallow-size\"}},[e._v(\"#\")]),e._v(\" 1.1 Shallow Size\")]),e._v(\" \"),s(\"p\",[s(\"strong\",[e._v(\"对象自身占用的内存大小，不包括他引用的对象\")])]),e._v(\" \"),s(\"p\",[e._v(\"针对非数组类型的对象，它的大小就是对象与他所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。\\n针对数组类型的对象，它的大小是数组元素对象的大小总和。\")]),e._v(\" \"),s(\"h3\",{attrs:{id:\"_1-2-retained-size\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-2-retained-size\"}},[e._v(\"#\")]),e._v(\" 1.2 Retained Size\")]),e._v(\" \"),s(\"p\",[e._v(\"Retained Size= \"),s(\"strong\",[e._v(\"当前对象大小+当前对象可直接或间接引用到的对象的大小总和\")]),e._v(\"(间接引用的含义：A->B->C, C就是间接引用)\")]),e._v(\" \"),s(\"p\",[e._v(\"换句话说，Retained Size 就是当前对象被GC后，从Heap 上总共能释放掉的内存，从Heap 上总共能释放掉的内存\")]),e._v(\" \"),s(\"p\",[e._v(\"不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被被当做Garbage。\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"_2-看图理解retained-size\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-看图理解retained-size\"}},[e._v(\"#\")]),e._v(\" 2. 看图理解Retained Size\")]),e._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:t(415),alt:\"image-20200107223438176\"}})]),e._v(\" \"),s(\"p\",[e._v(\"上图中，GC Roots直接引用了A和B 两个对象\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[s(\"p\",[e._v(\"A对象的Retained Size = A对象Shallow Size\")])]),e._v(\" \"),s(\"li\",[s(\"p\",[e._v(\"B对象的Reatined Size = B 对象的Shallow Size + C对象的Shallow Size\")]),e._v(\" \"),s(\"p\",[e._v(\"ps:这里不包含D对象，因为D对象被GCroot直接引用了\")])])]),e._v(\" \"),s(\"h3\",{attrs:{id:\"如果gc-roots不引用d对象\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如果gc-roots不引用d对象\"}},[e._v(\"#\")]),e._v(\" 如果GC Roots不引用D对象？\")]),e._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:t(416),alt:\"image-20200107223805147\"}})]),e._v(\" \"),s(\"p\",[e._v(\"此时，B对象的Retained Size=B对象的Shallow Size + C对象的Shallow Size + D对象的Shallow Size\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"参考文章\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考文章\"}},[e._v(\"#\")]),e._v(\" 参考文章\")]),e._v(\" \"),s(\"p\",[s(\"a\",{attrs:{href:\"https://www.iteye.com/blog/bjyzxxds-1532937\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Shallow heap & Retained heap\"),s(\"OutboundLink\")],1)])])}),[],!1,null,null,null);a.default=i.exports},415:function(e,a,t){e.exports=t.p+\"assets/img/image-20200107223438176.9337eb21.png\"},416:function(e,a,t){e.exports=t.p+\"assets/img/image-20200107223805147.cde134d6.png\"}}]);","extractedComments":[]}