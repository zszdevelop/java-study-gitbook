const e=JSON.parse('{"key":"v-05bb6961","path":"/db/redis/db-redis-x-cache.html","title":"Redis进阶  -  Redis缓存问题：一致性, 穿击, 穿透, 雪崩, 污染等","lang":"zh-CN","frontmatter":{"order":310,"category":["数据库","Redis"],"description":"Redis最常用的一个场景就是作为缓存，本文主要探讨Redis作为缓存，在实践中可能会有哪些问题？比如一致性, 穿击, 穿透, 雪崩, 污染等。 1. 为什么要理解Redis缓存问题 在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问Mysql等数据库。...","head":[["meta",{"property":"og:url","content":"https://zszdevelop.github.io/java-study-gitbook/java-study-gitbook/db/redis/db-redis-x-cache.html"}],["meta",{"property":"og:site_name","content":"Java学习笔记"}],["meta",{"property":"og:title","content":"Redis进阶  -  Redis缓存问题：一致性, 穿击, 穿透, 雪崩, 污染等"}],["meta",{"property":"og:description","content":"Redis最常用的一个场景就是作为缓存，本文主要探讨Redis作为缓存，在实践中可能会有哪些问题？比如一致性, 穿击, 穿透, 雪崩, 污染等。 1. 为什么要理解Redis缓存问题 在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问Mysql等数据库。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-02-20T13:42:31.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-02-20T13:42:31.000Z"}]]},"headers":[{"level":2,"title":"1. 为什么要理解Redis缓存问题","slug":"_1-为什么要理解redis缓存问题","link":"#_1-为什么要理解redis缓存问题","children":[]},{"level":2,"title":"2. 缓存穿透","slug":"_2-缓存穿透","link":"#_2-缓存穿透","children":[]},{"level":2,"title":"3. 缓存击穿","slug":"_3-缓存击穿","link":"#_3-缓存击穿","children":[]},{"level":2,"title":"4. 缓存雪崩","slug":"_4-缓存雪崩","link":"#_4-缓存雪崩","children":[]},{"level":2,"title":"5. 缓存污染（或满了）","slug":"_5-缓存污染-或满了","link":"#_5-缓存污染-或满了","children":[{"level":3,"title":"5.1 最大缓存设置多大","slug":"_5-1-最大缓存设置多大","link":"#_5-1-最大缓存设置多大","children":[]},{"level":3,"title":"5.2 缓存淘汰策略","slug":"_5-2-缓存淘汰策略","link":"#_5-2-缓存淘汰策略","children":[]}]},{"level":2,"title":"6. 数据库和缓存一致性","slug":"_6-数据库和缓存一致性","link":"#_6-数据库和缓存一致性","children":[{"level":3,"title":"6.1 四种相关模式","slug":"_6-1-四种相关模式","link":"#_6-1-四种相关模式","children":[]},{"level":3,"title":"6.2 方案：队列 + 重试机制","slug":"_6-2-方案-队列-重试机制","link":"#_6-2-方案-队列-重试机制","children":[]},{"level":3,"title":"6.3 方案：异步更新缓存(基于订阅binlog的同步机制)","slug":"_6-3-方案-异步更新缓存-基于订阅binlog的同步机制","link":"#_6-3-方案-异步更新缓存-基于订阅binlog的同步机制","children":[]}]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1676900551000,"updatedTime":1676900551000,"contributors":[{"name":"zszdevelop","email":"zszdevelop@163.com","commits":1}]},"readingTime":{"minutes":14.99,"words":4497},"filePathRelative":"db/redis/db-redis-x-cache.md","localizedDate":"2023年2月20日","autoDesc":true}');export{e as data};
