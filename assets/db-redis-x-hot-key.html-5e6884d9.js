import{_ as s,W as n,X as o,Y as a,Z as t,$ as i,a0 as p,D as r}from"./framework-0cf5f349.js";const l={},c=p(`<h1 id="redis进阶-redis热key问题" tabindex="-1"><a class="header-anchor" href="#redis进阶-redis热key问题" aria-hidden="true">#</a> Redis进阶 - Redis热key问题</h1><h2 id="_0-引言" tabindex="-1"><a class="header-anchor" href="#_0-引言" aria-hidden="true">#</a> 0. 引言</h2><p>其实热key问题说来也很简单，就是瞬间有几十万的请求去访问redis上某个固定的key，从而压垮缓存服务的情情况。 其实生活中也是有不少这样的例子。比如XX明星结婚。那么关于XX明星的Key就会瞬间增大，就会出现热数据问题。</p><blockquote><p><code>ps:</code>hot key和big key问题，大家一定要有所了解。</p></blockquote><p>本文预计分为如下几个部分</p><ul><li>热key问题</li><li>如何发现</li><li>业内方案</li></ul><h2 id="_1-热key问题" tabindex="-1"><a class="header-anchor" href="#_1-热key问题" aria-hidden="true">#</a> 1. 热Key问题</h2><p>上面提到，所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。 那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。</p><h2 id="_2-怎么发现热key" tabindex="-1"><a class="header-anchor" href="#_2-怎么发现热key" aria-hidden="true">#</a> 2. 怎么发现热key</h2><ul><li><em>方法一:凭借业务经验，进行预估哪些是热key</em> 其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。</li><li><em>方法二:在客户端进行收集</em> 这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。</li><li><em>方法三:在Proxy层做收集</em> 有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。</li></ul><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20221128232245563.png" alt="image-20221128232245563" tabindex="0" loading="lazy"><figcaption>image-20221128232245563</figcaption></figure><ul><li><em>方法四:用redis自带命令</em> (1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如<code>redis-faina</code>。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。 (2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。</li><li><em>方法五:自己抓包评估</em> Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。</li></ul><p>以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢？</p><h2 id="_3-如何解决" tabindex="-1"><a class="header-anchor" href="#_3-如何解决" aria-hidden="true">#</a> 3. 如何解决</h2><p>目前业内的方案有两种</p><h3 id="_3-1-利用二级缓存" tabindex="-1"><a class="header-anchor" href="#_3-1-利用二级缓存" aria-hidden="true">#</a> <em>3.1 利用二级缓存</em></h3><p>比如利用<code>ehcache</code>，或者一个<code>HashMap</code>都可以。在你发现热key以后，把热key加载到系统的JVM中。 针对这种热key请求，会直接从jvm中取，而不会走到redis层。 假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。 现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。</p><h3 id="_3-2-备份热key" tabindex="-1"><a class="header-anchor" href="#_3-2-备份热key" aria-hidden="true">#</a> <em>3.2 备份热key</em></h3><p>这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。 假设redis的集群数量为N，步骤如下图所示</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20221128232534600.png" alt="image-20221128232534600" tabindex="0" loading="lazy"><figcaption>image-20221128232534600</figcaption></figure><p>注:不一定是2N，你想取3N，4N都可以，看要求。 伪代码如下</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token builtin">const</span> <span class="token constant">M</span> <span class="token operator">=</span> <span class="token constant">N</span> <span class="token operator">*</span> <span class="token number">2</span>
<span class="token operator">//</span>生成随机数
<span class="token hvariable">random</span> <span class="token operator">=</span> <span class="token constant">GenRandom</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">M</span><span class="token punctuation">)</span>
<span class="token operator">//</span>构造备份新<span class="token hvariable">key</span>
<span class="token hvariable">bakHotKey</span> <span class="token operator">=</span> <span class="token hvariable">hotKey</span> <span class="token operator">+</span> “<span class="token hvariable">_</span>” <span class="token operator">+</span> <span class="token hvariable">random</span>
<span class="token keyword">data</span> <span class="token operator">=</span> <span class="token hvariable">redis</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">(</span><span class="token hvariable">bakHotKey</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token keyword">data</span> <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">{</span>
    <span class="token keyword">data</span> <span class="token operator">=</span> <span class="token constant">GetFromDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token hvariable">redis</span><span class="token punctuation">.</span><span class="token constant">SET</span><span class="token punctuation">(</span><span class="token hvariable">bakHotKey</span><span class="token punctuation">,</span> <span class="token hvariable">expireTime</span> <span class="token operator">+</span> <span class="token constant">GenRandom</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-业内方案" tabindex="-1"><a class="header-anchor" href="#_4-业内方案" aria-hidden="true">#</a> 4. 业内方案</h2><p>OK，其实看完上面的内容，大家可能会有一个疑问。</p><blockquote><p><strong>有办法在项目运行过程中，自动发现热key，然后程序自动处理么？</strong></p></blockquote><p>嗯，好问题，那我们来讲讲业内怎么做的。其实只有两步 (1)监控热key (2)通知系统做处理 正巧，前几天有赞出了一篇《有赞透明多级缓存解决方案（TMC）》，里头也有提到热点key问题，我们刚好借此说明</p><h3 id="_4-1-监控热key" tabindex="-1"><a class="header-anchor" href="#_4-1-监控热key" aria-hidden="true">#</a> 4.1 监控热key</h3><p>在监控热key方面，有赞用的是方式二：<strong>在客户端进行收集</strong>。 在《有赞透明多级缓存解决方案（TMC）》中有一句话提到</p><blockquote><p><strong>TMC 对原生jedis包的JedisPool和Jedis类做了改造，在JedisPool初始化过程中集成TMC“热点发现”+“本地缓存”功能Hermes-SDK包的初始化逻辑。</strong></p></blockquote><p>也就说人家改写了jedis原生的jar包，加入了Hermes-SDK包。 那Hermes-SDK包用来干嘛？ OK，就是做<strong>热点发现</strong>和<strong>本地缓存</strong>。 从监控的角度看，该包对于Jedis-Client的每次key值访问请求，Hermes-SDK 都会通过其通信模块将key访问事件异步上报给Hermes服务端集群，以便其根据上报数据进行“热点探测”。</p><p>当然，这只是其中一种方式，有的公司在监控方面用的是方式五:<strong>自己抓包评估</strong>。 具体是这么做的，先利用flink搭建一套流式计算系统。然后自己写一个抓包程序抓redis监听端口的数据，抓到数据后往kafka里丢。 接下来，流式计算系统消费kafka里的数据，进行数据统计即可，也能达到监控热key的目的。</p><h3 id="_4-2-通知系统做处理" tabindex="-1"><a class="header-anchor" href="#_4-2-通知系统做处理" aria-hidden="true">#</a> 4.2 通知系统做处理</h3><p>在这个角度，有赞用的是上面的解决方案一:利用二级缓存进行处理。 有赞在监控到热key后，Hermes服务端集群会通过各种手段通知各业务系统里的Hermes-SDK，告诉他们:&quot;老弟，这个key是热key，记得做本地缓存。&quot; 于是Hermes-SDK就会将该key缓存在本地，对于后面的请求。Hermes-SDK发现这个是一个热key，直接从本地中拿，而不会去访问集群。</p><p>除了这种通知方式以外。我们也可以这么做，比如你的流式计算系统监控到热key了，往zookeeper里头的某个节点里写。然后你的业务系统监听该节点，发现节点数据变化了，就代表发现热key。最后往本地缓存里写，也是可以的。</p><p>通知方式各种各样，大家可以自由发挥。本文只是提供一个思路。</p><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>`,36),d={href:"https://www.cnblogs.com/rjzheng/p/10874537.html",target:"_blank",rel:"noopener noreferrer"};function k(h,u){const e=r("ExternalLinkIcon");return n(),o("div",null,[c,a("p",null,[a("a",d,[t("谈谈redis的热key问题如何解决 "),i(e)])])])}const m=s(l,[["render",k],["__file","db-redis-x-hot-key.html.vue"]]);export{m as default};
