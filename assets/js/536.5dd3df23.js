(window.webpackJsonp=window.webpackJsonp||[]).push([[536],{915:function(_,v,t){"use strict";t.r(v);var a=t(26),e=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"amazon-s3详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#amazon-s3详解"}},[_._v("#")]),_._v(" Amazon-S3详解")]),_._v(" "),t("h2",{attrs:{id:"_1-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[_._v("#")]),_._v(" 1. 简介")]),_._v(" "),t("p",[t("strong",[_._v("AWS S3 全名是 Simple Storage Service，简便的存储服务")]),_._v("。为什么这么起名啊？它：")]),_._v(" "),t("ol",[t("li",[_._v("提供了统一的接口 REST/SOAP 来统一访问任何数据")]),_._v(" "),t("li",[_._v("对 S3 来说，存在里面的数据就是对象名（键），和数据（值）")]),_._v(" "),t("li",[_._v("不限量，单个文件最高可达 5TB")]),_._v(" "),t("li",[_._v("高速。每个 bucket 下每秒可达 3500 PUT/COPY/POST/DELETE 或 5500 GET/HEAD 请求")]),_._v(" "),t("li",[_._v("具备版本，权限控制能力")]),_._v(" "),t("li",[_._v("具备数据生命周期管理能力")])]),_._v(" "),t("p",[_._v("作为一个对象存储服务，S3 功能真的很完备。")]),_._v(" "),t("h2",{attrs:{id:"_2-基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-基本概念"}},[_._v("#")]),_._v(" 2. 基本概念")]),_._v(" "),t("h3",{attrs:{id:"_2-1-bucket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-bucket"}},[_._v("#")]),_._v(" 2.1 Bucket")]),_._v(" "),t("p",[_._v("要存储数据在 S3 里，首先我们要建立一个 Bucket。Bucket 默认是不公开的。")]),_._v(" "),t("p",[_._v("Bucket 有几个特点：")]),_._v(" "),t("ul",[t("li",[_._v("命名需全球唯一。每个帐号默认可建 100 个，可申请至最多 1000 个")]),_._v(" "),t("li",[_._v("创建者的拥有权不可转让，也不可以从一个 Region 转去别的 Region")]),_._v(" "),t("li",[_._v("没有对象存储数量限制")])]),_._v(" "),t("p",[_._v("Bucket 就像是电脑里面的某一个顶层分区。所有的对象都必须保存在某一个 bucket 下面。")]),_._v(" "),t("h3",{attrs:{id:"_2-2-object"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-object"}},[_._v("#")]),_._v(" 2.2 Object")]),_._v(" "),t("p",[_._v("Bucket 里面每一个存储的数据就是对象，由对象名（键），和数据（值）组成。")]),_._v(" "),t("p",[_._v("对象的键（Key）可以很长，甚至按照一定前缀格式来指定，从而模拟文件夹的层级结构，比如 "),t("code",[_._v("Photo/Family/2020-01-25-new-year/altogether.jpg")]),_._v("。")]),_._v(" "),t("p",[_._v("每一个对象其实还包含一些元信息（Meta-data），包括系统指定的文件类型，创建时间，加密算法等，和用户上传时指定的元信息。元信息在对象创建后都无法更改。")]),_._v(" "),t("p",[_._v("我们也可以为对象指定最多 10个标签（Tag），标签的键和值的最大长度是 128 和 256 个字符。这个标签和元信息有什么不同呢？标签是可以修改和新增的。它最大的好处，是可以结合权限控制，生命周期管理，和数据分析等使用。")]),_._v(" "),t("p",[_._v("单个文件上传最大是 5GB。超过的话，需要使用 multipart upload API。最大支持 5TB。")]),_._v(" "),t("h3",{attrs:{id:"_2-3-一致性特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-一致性特性"}},[_._v("#")]),_._v(" 2.3 一致性特性")]),_._v(" "),t("p",[_._v("对程序员来说，这么一个类似数据库的东西，肯定需要关心它的读写特性和一致性模型。")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("没有锁的功能")]),_._v("。如果同时（几乎）发起两个更新对象的 PUT 请求，键相同，那么，以到达 S3 时间先后处理更新。")]),_._v(" "),t("li",[_._v("不同对象的更新**，没法做到原子操作**。")]),_._v(" "),t("li",[_._v("对全新的对象来说，它是 Read-after-Write Consistency 的。也就是写了之后马上读，肯定就是你刚才上传的数据。")]),_._v(" "),t("li",[_._v("如果你要"),t("strong",[_._v("更新数据，那就变成 Eventual Consistency （最终一致性）了。也就是说，更新后马上读，可能是旧的数据，也可能是新的。")])])]),_._v(" "),t("p",[_._v("这里有一个比较坑的地方是，如果你先调用 GET 请求访问一个不存在的资源，S3 告诉你它不存在。然后你马上上传数据，再调用一个 GET，这时候是有可能拿不回来的。")]),_._v(" "),t("h2",{attrs:{id:"_3-存储级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-存储级别"}},[_._v("#")]),_._v(" 3. 存储级别")]),_._v(" "),t("p",[_._v("作为一个“云盘”，S3 的好处是可以把你存储的数据，按不同的存储级别来计费。这个存储级别是每个对象不同，上传时指定的。")]),_._v(" "),t("p",[_._v("我们看看不同的场景，应该选择哪种级别的存储：")]),_._v(" "),t("ul",[t("li",[_._v("经常访问的数据对象")])]),_._v(" "),t("ol",[t("li",[_._v("STANDARD - 这是最普通，最常用的类型")]),_._v(" "),t("li",[_._v("REDUCED_REDUNDANCY (RRS) - 不建议使用。仅为不重要，可再建数据设计，还有每年平均 0.01% 数据丢失的可能性。")])]),_._v(" "),t("ul",[t("li",[_._v("按访问频率自动优化的数据")])]),_._v(" "),t("ol",[t("li",[_._v("INTELLIGENT_TIERING - 可以智能地把不热门的数据自动转级别。但是，每个文件最低收费标准是 128KB，存 30天。")])]),_._v(" "),t("ul",[t("li",[_._v("不经常访问的数据")])]),_._v(" "),t("ol",[t("li",[_._v("STANDARD_IA")]),_._v(" "),t("li",[_._v("ONEZONE_IA")])]),_._v(" "),t("p",[_._v("AWS 一个 Region，有两到三个 Zone。这两种级别的区别就是，One Zone 的数据就单点保存，丢了就丢了。")]),_._v(" "),t("ul",[t("li",[_._v("归档的数据")])]),_._v(" "),t("ol",[t("li",[_._v("S3 Glacier - 最低保存 90天。取出时间 1分钟至 12小时。")]),_._v(" "),t("li",[_._v("S3 Glacier Deep Archive - 最低保存 180天。默认 12小时内取出。")])]),_._v(" "),t("p",[_._v("S3 计费的大头主要是存储容量。但是，S3 还会按照数据获取的次数，和传输容量来计费。越不常访问的级别，虽然存储便宜，但是访问贵。INTELLIGENT_TIERING 还会收监测和管理费用。")]),_._v(" "),t("h3",{attrs:{id:"_3-1-生命周期的管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-生命周期的管理"}},[_._v("#")]),_._v(" 3.1 生命周期的管理")]),_._v(" "),t("p",[_._v("除了手动指定，或者使用 INTELLIGENT_TIERING 外，S3 其实还可以让我们在 bucket 上定义生命周期管理的策略（Policy），来自动转换对象的存储级别。")]),_._v(" "),t("p",[_._v("生命周期的管理可以做到： 1. 转换存储级别 2. 过期删除")]),_._v(" "),t("h2",{attrs:{id:"_4-数据安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-数据安全"}},[_._v("#")]),_._v(" 4. 数据安全")]),_._v(" "),t("p",[_._v("数据安全，是数据存储服务非常重要的一部分。S3 提供了很多方面的功能来保障这一点。")]),_._v(" "),t("h3",{attrs:{id:"_4-1-多版本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-多版本"}},[_._v("#")]),_._v(" 4.1 多版本")]),_._v(" "),t("p",[_._v("不小心把数据删除了的痛，程序员应该都懂。但是，后悔药是没有的。所以，我们很多时候并不会做永久删除，而是实现软删除的功能。S3 就提供了多版本的功能。只要 bucket 打开了多版本的选项，每次对象的更新都会新加一个版本，而不是覆盖。删除对象，也只是新增一个删除标识。")]),_._v(" "),t("p",[_._v("当然，你要强行删除特定版本的数据也是可以的，它只是让这件事变得难一些而已。它甚至可以把 bucket 设置成只有通过 MFA 认证的请求才能实现永久删除。")]),_._v(" "),t("p",[_._v("要注意的是： 1. 打开版本控制的 bucket，是没法关闭的，顶多可以暂停。也就是说，暂停后的 bucket，新加对象的时候，版本 id 会设为 null。 2. 无论打开，或者暂停版本控制，对 bucket 内已经存在的对象是没有影响的。")]),_._v(" "),t("h3",{attrs:{id:"_4-2-锁定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-锁定"}},[_._v("#")]),_._v(" 4.2 锁定")]),_._v(" "),t("p",[_._v("除了使用多版本控制让覆盖或者删除变得更难，S3 还可以锁定特定版本的对象。这种模型被称为 write-once-read-many (WORM)。")]),_._v(" "),t("p",[_._v("有两种锁定的方式： "),t("em",[_._v("设定保留期限 - 在某固定期限内，对象 WORM。")]),_._v(" 法定留存 - 仅当这个留存标识被删除后，对象才能被覆盖或删除。")]),_._v(" "),t("p",[_._v("一个特定版本的对象，可以同时设置这两种保护，或任意一种。")]),_._v(" "),t("p",[_._v("因为锁定是针对特定版本的对象，如果你的更改或删除操作请求只根据对象的键，那它还是允许你新增一个版本，或加上删除标识。只是这个锁定，还能防止对象因为生命周期的设置而被删除掉。")]),_._v(" "),t("h3",{attrs:{id:"_4-3-服务端加密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-服务端加密"}},[_._v("#")]),_._v(" 4.3 服务端加密")]),_._v(" "),t("p",[_._v("数据传输过程（in-transit）中的保护，现在基本都由 SSL/TLS 来实现的。AWS 也提供 VPN 或者网络直连服务。")]),_._v(" "),t("p",[_._v("S3 提供了服务端数据加密的功能，可实现数据的存储（at rest）方面的安全。不过它只支持对称加密，不支持非对称加密。虽然你可以本地把数据加密了再上传到 S3，但是，这需要自己保护好密钥，其实更不容易。")]),_._v(" "),t("p",[_._v("服务端加密开启后，bucket 内已经存在的对象不会被自动加密。而且，只有数据被加密，元信息（meta data），标签（Tag）不会被加密。")]),_._v(" "),t("p",[_._v("S3 的服务端加密有三种方式：")]),_._v(" "),t("ol",[t("li",[_._v("SSE-S3 - S3 自管理的密钥，使用 AES-256 加密算法。每个对象的密钥不同，并且它还被定期更换的主密钥同时加密。")]),_._v(" "),t("li",[_._v("SSE-KMS - 密钥存放在 KMS（软硬件结合的密钥管理系统）。")]),_._v(" "),t("li",[_._v("SSE-C - 在请求时自己提供密钥，S3 只管加解密逻辑和存储。S3 不保存密钥，只保存随机加盐的 HMAC 值来验证今后请求的合法性。")])]),_._v(" "),t("p",[_._v("这里主要说一下 S3 使用 SSE-KMS 特点：")]),_._v(" "),t("ul",[t("li",[_._v("启用前，如果没有指定客户管理的 CMK（customer master key），S3 会自动创建一个由 AWS 管理的 CMK")]),_._v(" "),t("li",[_._v("加密数据的密钥，同时也被加密，并和数据保存在一起")]),_._v(" "),t("li",[_._v("有请求频率限制")]),_._v(" "),t("li",[_._v("只支持对称密钥")]),_._v(" "),t("li",[_._v("CMK 必须和 bucket 在同一个区（Region）")])]),_._v(" "),t("h2",{attrs:{id:"_5-副本备份"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-副本备份"}},[_._v("#")]),_._v(" 5. 副本备份")]),_._v(" "),t("p",[_._v("S3 不仅通过多点存储提高健壮性，还提供了自动的异步数据备份的功能。不仅支持同 Region，不同 bucket 的备份，还支持跨 Region，不同帐号的备份。要开启副本备份，首先必须在源和目标 bucket 同时打开多版本的设置。")]),_._v(" "),t("h3",{attrs:{id:"_5-1-为什么要使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-为什么要使用"}},[_._v("#")]),_._v(" 5.1 为什么要使用？")]),_._v(" "),t("ul",[t("li",[_._v("备份同时保留元数据")]),_._v(" "),t("li",[_._v("备份至不同存储级别")]),_._v(" "),t("li",[_._v("更改备份数据的拥有权")]),_._v(" "),t("li",[_._v("15 分钟内自动备份")])]),_._v(" "),t("h3",{attrs:{id:"_5-2-什么时候跨区备份-crr"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-什么时候跨区备份-crr"}},[_._v("#")]),_._v(" 5.2 什么时候跨区备份（CRR）")]),_._v(" "),t("ul",[t("li",[_._v("满足监管需求")]),_._v(" "),t("li",[_._v("减少数据传输延时（地域原因）")]),_._v(" "),t("li",[_._v("提高数据操作的效率")])]),_._v(" "),t("h3",{attrs:{id:"_5-3-什么时候同区备份-srr"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-什么时候同区备份-srr"}},[_._v("#")]),_._v(" 5.3 什么时候同区备份（SRR）")]),_._v(" "),t("ul",[t("li",[_._v("合并日志")]),_._v(" "),t("li",[_._v("生产和测试用户间数据同步")]),_._v(" "),t("li",[_._v("满足数据主权法规")])]),_._v(" "),t("h3",{attrs:{id:"_5-4-什么会同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-什么会同步"}},[_._v("#")]),_._v(" 5.4 什么会同步？")]),_._v(" "),t("ul",[t("li",[_._v("备份配置生效后新建的对象")]),_._v(" "),t("li",[_._v("没加密的对象")]),_._v(" "),t("li",[_._v("通过 SSE-S3 或者 SSE-KMS CMK（必须显式启用）加密的对象")]),_._v(" "),t("li",[_._v("对象元数据")]),_._v(" "),t("li",[_._v("bucket 拥有者有权读取的对象")]),_._v(" "),t("li",[_._v("对象 ACL 除非备份同属一个 aws 帐号")]),_._v(" "),t("li",[_._v("对象标签")]),_._v(" "),t("li",[_._v("对象的锁信息")])]),_._v(" "),t("h3",{attrs:{id:"_5-4-什么不同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-什么不同步"}},[_._v("#")]),_._v(" 5.4 什么不同步？")]),_._v(" "),t("ul",[t("li",[_._v("备份配置生效前新建的对象")]),_._v(" "),t("li",[_._v("使用 SSE-C 加密的对象")]),_._v(" "),t("li",[_._v("保存在 Glacier 或 Glacier Deep Archive 的对象")]),_._v(" "),t("li",[_._v("bucket 级别子资源的更新")]),_._v(" "),t("li",[_._v("由于生命周期配置导致的操作")]),_._v(" "),t("li",[_._v("源 bucket 中本来就是副本的对象")]),_._v(" "),t("li",[_._v("删除标识")]),_._v(" "),t("li",[_._v("源 bucket 中被删除的特定版本的对象")])]),_._v(" "),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[_._v("#")]),_._v(" 参考文章")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/112057573",target:"_blank",rel:"noopener noreferrer"}},[_._v("一文读懂 AWS S3"),t("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=e.exports}}]);