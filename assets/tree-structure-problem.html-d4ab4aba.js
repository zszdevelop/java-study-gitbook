import{_ as a,W as e,X as t,a0 as s}from"./framework-0cf5f349.js";const n={},d=s(`<h1 id="类似部门表查询子部门树结构" tabindex="-1"><a class="header-anchor" href="#类似部门表查询子部门树结构" aria-hidden="true">#</a> 类似部门表查询子部门树结构</h1><h2 id="_1-问题背景" tabindex="-1"><a class="header-anchor" href="#_1-问题背景" aria-hidden="true">#</a> 1. 问题背景</h2><p>假设类似部门表这种结构的数据有 100w条。层级大概有10层</p><table><thead><tr><th>id</th><th>name</th><th>pid</th></tr></thead><tbody><tr><td>1</td><td>总公司</td><td>0</td></tr><tr><td>2</td><td>分公司1</td><td>1</td></tr><tr><td>3</td><td>分公司2</td><td>1</td></tr><tr><td>4</td><td>部门1</td><td>2</td></tr><tr><td>....</td><td></td><td></td></tr></tbody></table><p>我们需要将部门表的转化为树结构</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/blogimage-master/image-20210522110741641.png" alt="image-20210522110741641" tabindex="0" loading="lazy"><figcaption>image-20210522110741641</figcaption></figure><h2 id="_2-问题" tabindex="-1"><a class="header-anchor" href="#_2-问题" aria-hidden="true">#</a> 2. 问题</h2><p>正常全表转树结构是没有任何问题的，但我实际想要的只有紫色框框的数据</p><ol><li>并不是每个用户都能看到所有的组织机构数据（例如分公司1只能看到分公司1下的所有数据）</li><li><strong>查询搜索</strong>的时候也需要只查拥有的权限数据</li></ol><h2 id="_3-解决方案" tabindex="-1"><a class="header-anchor" href="#_3-解决方案" aria-hidden="true">#</a> 3. 解决方案</h2><h3 id="_3-1-同样全表查出后-找到自己的部-id-然后遍历出所有子树" tabindex="-1"><a class="header-anchor" href="#_3-1-同样全表查出后-找到自己的部-id-然后遍历出所有子树" aria-hidden="true">#</a> 3.1 同样全表查出后,找到自己的部 id,然后遍历出所有子树</h3><p>面临的问题：数据量实在太大,我下级部门可能只有100个,但我却查了100w数据出来,去找所有子树</p><h3 id="_3-2-用户只查自己的单位-点击下级的时候-再查pid为自己的下级部门" tabindex="-1"><a class="header-anchor" href="#_3-2-用户只查自己的单位-点击下级的时候-再查pid为自己的下级部门" aria-hidden="true">#</a> 3.2 用户只查自己的单位,点击下级的时候,再查pid为自己的下级部门</h3><p>问题:我搜案的时候,无法正常搜案。因为我还要知道下级的下级是否包含要搜案的数据。又得 遍历多次查询</p><h3 id="_3-3-新增父级路径-推荐" tabindex="-1"><a class="header-anchor" href="#_3-3-新增父级路径-推荐" aria-hidden="true">#</a> 3.3 新增父级路径（推荐）</h3><p>只要部门父级id路径前缀（包含自己节点）相同，则为该节点的所有子节点。</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/blogimage-master/image-20210522112314946.png" alt="image-20210522112314946" tabindex="0" loading="lazy"><figcaption>image-20210522112314946</figcaption></figure><h2 id="_4-代码实现" tabindex="-1"><a class="header-anchor" href="#_4-代码实现" aria-hidden="true">#</a> 4. 代码实现</h2><ol><li><p>Sql 语句</p><ol><li><p>方式1：like</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> sys_dept
<span class="token keyword">where</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span> 
<span class="token operator">AND</span> ancestors <span class="token operator">like</span> concat<span class="token punctuation">(</span><span class="token comment">#{ancestors},&#39;%&#39;)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>FIND_IN_SET</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> sys_dept <span class="token keyword">where</span> FIND_IN_SET<span class="token punctuation">(</span><span class="token comment">#{deptId}, ancestors) &lt;![CDATA[ &lt;&gt; ]]&gt; 0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>MySQL提供了一个名为<code>FIND_IN_SET()</code>的内置字符串函数，允许您在逗号分隔的字符串列表中查找指定字符串的位置。</p></blockquote><blockquote><p>oracle 没有该函数，需要自定义函数</p></blockquote></li></ol></li></ol>`,19),r=[d];function i(o,l){return e(),t("div",null,r)}const p=a(n,[["render",i],["__file","tree-structure-problem.html.vue"]]);export{p as default};
