import{_ as e,W as i,X as s,a0 as t}from"./framework-0cf5f349.js";const d={},n=t('<h1 id="redis连接客户端选择-jedis-redisson-lettuce" tabindex="-1"><a class="header-anchor" href="#redis连接客户端选择-jedis-redisson-lettuce" aria-hidden="true">#</a> redis连接客户端选择：Jedis,Redisson,Lettuce</h1><p>在spring boot2之后，对redis连接的支持，默认就采用了lettuce。这就一定程度说明了lettuce 和Jedis的优劣。</p><h2 id="_1-redis-常见连接客户端" tabindex="-1"><a class="header-anchor" href="#_1-redis-常见连接客户端" aria-hidden="true">#</a> 1. redis 常见连接客户端</h2><ul><li><p>Jedis：是老牌的Redis的Java实现客户端，提供了比较全面的Redis命令的支持</p><p>优势：比较全面的提供了Redis的操作特性</p></li><li><p>Redisson：实现了分布式和可扩展的Java数据结构。</p><p>优势：促使使用者对Redis的关注分离，提供很多分布式相关操作服务，例如，<strong>分布式锁，分布式集合，可通过Redis支持延迟队列</strong></p></li><li><p>Lettuce：高级Redis客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器。</p><p>优势：<strong>基于Netty框架的事件驱动的通信层</strong>，其方法调用是异步的。Lettuce的API是<strong>线程安全</strong>的，所以可以操作单个Lettuce连接来完成各种操作</p></li></ul><h2 id="_2-lettuce和jedis比较" tabindex="-1"><a class="header-anchor" href="#_2-lettuce和jedis比较" aria-hidden="true">#</a> 2. lettuce和jedis比较</h2><p>jedis是直接连接redis server,如果在多线程环境下是<strong>非线程安全</strong>的，这个时候只有<strong>使用连接池，为每个jedis实例增加物理连接 ；</strong></p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/blogimage-master/img/image-20191005112810662.png" alt="image-20191005112810662" tabindex="0" loading="lazy"><figcaption>image-20191005112810662</figcaption></figure><p>lettuce的连接是基于Netty的，连接实例（StatefulRedisConnection）可以在多个线程间并发访问，StatefulRedisConnection是线程安全的，所以一个连接实例可以满足多线程环境下的并发访问，当然这也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。</p><p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><p>总结： 优先使用Lettuce，如果需要分布式锁，分布式集合等分布式的高级特性，添加Redisson结合使用，因为Redisson本身对字符串的操作支持很差。</p>',10),a=[n];function r(o,c){return i(),s("div",null,a)}const p=e(d,[["render",r],["__file","redis-y-action-client.html.vue"]]);export{p as default};
