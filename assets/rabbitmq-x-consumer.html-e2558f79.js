import{_ as p,W as o,X as c,Y as s,Z as n,$ as t,a0 as e,D as u}from"./framework-0cf5f349.js";const i={},l=e(`<h1 id="rabbitmq进阶-消费端要点介绍" tabindex="-1"><a class="header-anchor" href="#rabbitmq进阶-消费端要点介绍" aria-hidden="true">#</a> RabbitMQ进阶 - 消费端要点介绍</h1><h2 id="_1-简介" tabindex="-1"><a class="header-anchor" href="#_1-简介" aria-hidden="true">#</a> 1. 简介</h2><p>消费者客户端可以通过 <strong>推模式</strong> 和 <strong>拉模式</strong> 来获取并消费消息，RabbitMQ 把消息推送后（或客户端主动 ACK）后，RabbitMQ 把当前消息从队列中标记清除。如果由于某些原因无法处理当前接受到的信息，可以通过 <code>channel.basicNack</code> 或则 <code>channel.basicReject</code> 来拒绝掉。</p><p>对于消费者来说，还有几点需要注意：</p><ul><li>消息分发</li><li>消息顺序性</li><li>弃用 QueueingConsumer</li></ul><h2 id="_2-消息分发" tabindex="-1"><a class="header-anchor" href="#_2-消息分发" aria-hidden="true">#</a> 2. 消息分发</h2><p>当 RabbitMQ <strong>队列有多个消费者</strong> 时，队列收到的消息将以 <strong>轮询（round-robin）</strong> 方式分发给消费者，每条消息只会发送给订阅列表里的 <strong>一个消费者</strong>。这种方式是专门为并发程序设计的，如果程序处理不过来，只要增加更多的消费者来处理消息即可。</p><p>很多时候轮询的分发机制也有问题。默认情况下，如果有 n 个消费者，RabbitMQ 会将第 m 条消息分发给第 <code>m%n</code> (取余) 个消费者。RabbitMQ <strong>不管消费者是否消费并已经确认</strong>（Basic.Ack）消息。就可能会导致：某些消费者来不及处理消息，有些处理得很快的情况。</p><p>这种情况，需要 <strong>限制信道上</strong> 的消费者所能 <strong>保持的最大未确认消息的数量</strong>，通过 <code>channel.basicQos(int prefetchCount)</code> 方法。</p><p>举例说明：在订阅队列之前，消费者设置 <code>channel.basicQos(5)</code>，再订阅队列。 RabbitMQ 会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果到达了设置上限，就不会向这个消费者再发送任何消息。直到消费者确认了某条消费者之后，RabbitMQ 把对应的计数器 -1，继续分发消息。</p><p>注意要点：<code>Basic.Qos</code> 对拉模式无效</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token keyword">int</span> prefetchSize<span class="token punctuation">,</span> <span class="token keyword">int</span> prefetchCount<span class="token punctuation">,</span> <span class="token keyword">boolean</span> global<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>prefetchSize：消费者所能接受未确认消息的总体大小的上限（单位为 B），设置为 0 时，表示无上限</p></li><li><p>prefetchCount：消费者所能接受最大未确认消息的数量</p></li><li><p>global：</p><p>一个信道可以消费多个队列</p><p>当该值大于 0 时，这个信道需要和各个队列协调，确保发送的消息都没有超过所限定的 prefetchCount。这会让 RabbitMQ 的性能降低，尤其当这些队列分散在集群中的多个 Broker 节点之中。为了解决这个性能问题，定义了 global 参数</p><table><thead><tr><th style="text-align:center;">global 参数</th><th>AMQP 0-9-1</th><th>RabbitMQ</th></tr></thead><tbody><tr><td style="text-align:center;">false</td><td>信道上所有的消费者都要遵从 prefetchCount 的限制</td><td>信道上所有的消费者都要遵从 prefetchCount 的限制</td></tr><tr><td style="text-align:center;">true</td><td>当前通信链路（Connection）上所有的消费者需要遵循从 prefetchCount 的限制</td><td>信道上所有的消费者都要遵从 prefetchCount 的限制（这里不知道书上是不是写错了？）</td></tr></tbody></table><p>channel.basicQos 只针对单个消费者的。对于同一个信道上的多个消费者而言，如果设置了 prefetchCount ，则都会生效。</p><p>如下代码，各自的能接收到的未确认消息上限都是 10</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">&quot;queue1&quot;</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span>consumerl1<span class="token punctuation">)</span>
channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">&quot;queue2&quot;</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span>consumerl2<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果同时设置了 global 为 false 和 true 呢？他们两个的限制都有效果：如下面这段代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">basicQos</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">&quot;queue1&quot;</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> consumerl1<span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span><span class="token string">&quot;queue2&quot;</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> consumerl2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么生效情况如下：</p><ul><li>每个消费者最多可收到 3 个未确认的消息</li><li>两个消费者最多可收到 5 个未确认的消息</li></ul><p>这种设置方式，会增加 RabbitMQ 的负载，会使用更多的资源来协调完成这些限制。建议用默认值的 false。</p></li></ul><h2 id="_3-消息顺序性" tabindex="-1"><a class="header-anchor" href="#_3-消息顺序性" aria-hidden="true">#</a> 3. 消息顺序性</h2><p>指：消费者 <strong>消费到的消息</strong> 和发送者 <strong>发布的消息</strong> 顺序是一致的。</p><p>如：发布 <code>1,2,3</code> 那么消费的顺序也是 <code>1,2,3</code></p><p>在 <strong>单个生产者和单个消费者的情况下，消息的有序性是能保证的</strong>，也是可验证的。在多消费者和多生产者的情况下，无法确定消息到达 Broker 的前后顺序，也无法确定客户端消费的顺序，这个其实是正常现象。分布式中本来就存在这样的现象。</p><p>有如下几种情况，消息的顺序性会被打破：但都是正常现象：</p><ul><li>使用事物机制时，发送失败，使用另一个线程补发此消息。此时消息就不能保证按照 <code>1,2,3,4</code> 的顺序到达 Broker 了</li><li>使用不同的消息过期时间，先过期的先被消费</li><li>使用优先级消息，优先级高的先被消费</li><li>客户端使用 <code>Basic.Nack/.Reject</code> 将消息拒绝时，同时 requeue= true， 消息重入队列后，也无法保证消息顺序还和发送的时候是一致的</li></ul><p>从以上点可以看到，在很多场景下，并不能保证消息的顺序性。</p><p>如果想要实现消息的有序性，则可以通过在消息体内增加全部有序标识，程序端自己实现逻辑判定</p><h2 id="_4-启用-queuingconsumer" tabindex="-1"><a class="header-anchor" href="#_4-启用-queuingconsumer" aria-hidden="true">#</a> 4. 启用 QueuingConsumer</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    queueingConsumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueueingConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>replyQueue<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> queueingConsumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">String</span> corrid <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">correlationId</span><span class="token punctuation">(</span>corrid<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">replyTo</span><span class="token punctuation">(</span>replyQueue<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> requestQueue<span class="token punctuation">,</span> properties<span class="token punctuation">,</span> <span class="token string">&quot;message&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 想服务端发送后，轮询，知道回去到服务端的响应为止</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">QueueingConsumer<span class="token punctuation">.</span>Delivery</span> delivery <span class="token operator">=</span> queueingConsumer<span class="token punctuation">.</span><span class="token function">nextDelivery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>delivery<span class="token punctuation">.</span><span class="token function">getProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCorrelationId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>corrid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>delivery<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,23),r={href:"https://zq99299.github.io/mq-tutorial/rabbitmq-ac/04/06.html",target:"_blank",rel:"noopener noreferrer"},k=s("code",null,"@Deprecated",-1),d=e('<p>是因为该类有几个大缺陷：比如内存溢出问题，由于某些原因，队列中堆积了比较多的消息，可能导致消费者客户端内存溢出假死，于是发生恶性循环，队列消息不断堆积而得不到消费。</p><p>导致内存溢出的原因是：QueuingConsumer 内部使用 LinkedBlockingQueue 来缓存消息，当设置的 <code>Basic.Qos</code> 数量太大的时候，消息体也很大（如一个消息 200M），那么就会导致内存溢出。可通过限制 qos 的数量来解决这个问题，但是一定 <strong>要在订阅之前设置</strong></p><p>QueuingConsumer 还包括以下缺陷（包括但不限于）：</p><ul><li>会拖累同一个 Connection 下的所有通道，使其性能降低</li><li>同步递归调用 QueuingConsumer 会产生死锁</li><li>RabbitMQ 的自动连接恢复机制（automatic Connection recovery） 不支持 QueuingConsumer 的这种形式</li><li>QueuingConsumer 不是事件驱动的</li></ul><p>所以还是使用 <code>DefaultConsumer</code> 之类的来订阅队列。</p><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>',6),b={href:"https://zq99299.github.io/mq-tutorial/rabbitmq-ac/04/09.html",target:"_blank",rel:"noopener noreferrer"};function m(v,h){const a=u("ExternalLinkIcon");return o(),c("div",null,[l,s("p",null,[n("前面讲解 "),s("a",r,[n("RPC 实现"),t(a)]),n(" 中用到过这个类，如上的代码片段。在 RabbitMQ 4.x 中被标记为 "),k,n(" 了。")]),d,s("p",null,[s("a",b,[n("消费端要点介绍"),t(a)])])])}const f=p(i,[["render",m],["__file","rabbitmq-x-consumer.html.vue"]]);export{f as default};
