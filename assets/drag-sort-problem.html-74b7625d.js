import{_ as i,W as o,X as r,Y as e,Z as d,$ as l,a0 as c,D as t}from"./framework-0cf5f349.js";const p={},h=c('<h1 id="拖拽排序后端设计思路" tabindex="-1"><a class="header-anchor" href="#拖拽排序后端设计思路" aria-hidden="true">#</a> 拖拽排序后端设计思路</h1><h2 id="_1-背景" tabindex="-1"><a class="header-anchor" href="#_1-背景" aria-hidden="true">#</a> 1. 背景</h2><p>最近做项目的时候遇到一个问题，就是前端需要对图片材料等拖拽排序。但排序后怎么存储？是批量保存所有顺序</p><h2 id="_2-需求描述" tabindex="-1"><a class="header-anchor" href="#_2-需求描述" aria-hidden="true">#</a> 2. 需求描述</h2><ul><li>允许更改元素的排序；</li><li>允许新增数据，并更新现有排序；</li><li>允许删除数据，并更新现有排序。</li></ul><h2 id="_3-解决方案" tabindex="-1"><a class="header-anchor" href="#_3-解决方案" aria-hidden="true">#</a> 3. 解决方案</h2><h3 id="_3-1-方案一-全量更新元素位置" tabindex="-1"><a class="header-anchor" href="#_3-1-方案一-全量更新元素位置" aria-hidden="true">#</a> 3.1 方案一： 全量更新元素位置</h3><ul><li><p>适用场景：</p><p>排序元素数量较少</p></li><li><p>原理：</p><p>每个元素拥有一个字段，表示元素当前排序的位置。通过前端排序，将排好的元素位置，一次性发送到后端。然后，后端统一更新所有元素的位置。</p></li><li><p>缺点</p><p>数据量过大，会导致频繁修改，造成数据库IO瓶颈</p></li><li><p>总结：</p><p>此方法仅适用于排序元素较少（例如，总元素为5~15个）的场景。对于大量数据排序并不适用</p></li></ul><h3 id="_3-2-取中值法-推荐" tabindex="-1"><a class="header-anchor" href="#_3-2-取中值法-推荐" aria-hidden="true">#</a> 3.2 取中值法（推荐）</h3><p>原理与实现步骤：</p><ol><li>创建元素时给元素赋默认位置（<code>pos</code>字段记录该值）。赋值规则为，当创建第一个元素时，默认位置赋值为65536，第二个元素为 <code>2 * 65536 = 13172</code>，增加第N个元素时，位置赋值为N*65536。</li><li>当拖拽改变元素位置时，更新 <code>pos</code>。更新规则如下：</li></ol><ul><li>调整一个元素到两个元素中间时，<code>(pre_item.pos + after_item.pos）/ 2 = pos</code></li><li>调整一个元素到第一个元素时， <code>old_first_item.pos / 2 = pos</code></li><li>调整一个元素到最后一个元素时， <code>old_last_item.post + 65536 = pos</code></li></ul><ol><li>当前后两个元素的数值，不满足整数时，更新所有元素的排序。依次给每个元素的 <code>pos</code>赋新值。例如，第一位赋值65536，第二位为<code>2 * 65536</code>，第N位赋值N*65536。</li></ol><p>通过取中值的方法，改变元素的位置。当需要按序获取时，只需要对 <code>pos</code>进行排序，就可以获取元素的位置。</p><h4 id="_3-2-1-重排问题方案" tabindex="-1"><a class="header-anchor" href="#_3-2-1-重排问题方案" aria-hidden="true">#</a> 3.2.1 重排问题方案</h4><ul><li><p>方案1：浮点数</p><p>可以使用浮点数储存 <code>pos</code>，但是需要考虑数据库存储的精度问题。而且，数值过小，会在前端丢失精度，元素排序会出现问题</p></li><li><p>方案2（推荐）：数值过小重排</p><p>如果在接口层，当检测到中值过小，则对所有元素进行重排，接口相应速度会存在问题</p></li><li><p>方案3：定时重排</p><p>利用定时任务每天对所有元素定时重排，来解决单次接口的性能问题。个人觉得这个方法，还是存在问题。若定时任务不及时，那么排序由于精度问题</p></li></ul><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>',17),n={href:"https://www.jianshu.com/p/9ee708e43ebf",target:"_blank",rel:"noopener noreferrer"};function s(_,u){const a=t("ExternalLinkIcon");return o(),r("div",null,[h,e("p",null,[e("a",n,[d("拖拽排序后端设计与实现"),l(a)])])])}const m=i(p,[["render",s],["__file","drag-sort-problem.html.vue"]]);export{m as default};
