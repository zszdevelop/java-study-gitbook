import{_ as o,W as l,X as a,Y as e,Z as t,$ as r,a0 as c,D as n}from"./framework-0cf5f349.js";const s={},d=c('<h1 id="消息中心各场景消息发送逻辑" tabindex="-1"><a class="header-anchor" href="#消息中心各场景消息发送逻辑" aria-hidden="true">#</a> 消息中心各场景消息发送逻辑</h1><h2 id="_1-简介" tabindex="-1"><a class="header-anchor" href="#_1-简介" aria-hidden="true">#</a> 1. 简介</h2><p>消息中心在各场景下的发送逻辑是不一致的，例如</p><ul><li>发送给单人的业务消息。我们希望发送完消息后，用户立即收到消息</li><li>而像类似通知公告这类消息，面向的是所有用户，那么我们不可能一次性发给所有用户。所以我们采用登录或进入首页后，重新拉取新消息的模式</li></ul><h2 id="_2-接口设计" tabindex="-1"><a class="header-anchor" href="#_2-接口设计" aria-hidden="true">#</a> 2. 接口设计</h2><p>NotifyService拥有以下方法:</p><ul><li>createAnnounce(content, sender) <ol><li>往Notify表中插入一条公告记录</li></ol></li><li>createRemind(target, targetType, action, sender, content) <ol><li>往Notify表中插入一条提醒记录</li></ol></li><li>createMessage(content, sender, receiver) <ol><li>往Notify表中插入一条信息记录</li><li>往UserNotify表中插入一条记录，并关联新建的Notify</li></ol></li><li>pullAnnounce(user) <ol><li>从UserNotify中获取最近的一条公告信息的创建时间: <code>lastTime</code></li><li>用<code>lastTime</code>作为过滤条件，查询Notify的公告信息</li><li>新建UserNotify并关联查询出来的公告信息</li></ol></li><li>pullRemind(user) <ol><li>查询用户的订阅表，得到用户的一系列订阅记录</li><li>通过每一条的订阅记录的<code>target</code>、<code>targetType</code>、<code>action</code>、<code>createdAt</code>去查询Notify表，获取订阅的Notify记录。（注意订阅时间必须早于提醒创建时间）</li><li>查询用户的配置文件SubscriptionConfig，如果没有则使用默认的配置DefaultSubscriptionConfig</li><li>使用订阅配置，过滤查询出来的Notify</li><li>使用过滤好的Notify作为关联新建UserNotify</li></ol></li><li>subscribe(user, target, targetType, reason) <ol><li>通过reason，查询NotifyConfig，获取对应的动作组:<code>actions</code></li><li>遍历动作组，每一个动作新建一则Subscription记录</li></ol></li><li>cancelSubscription(user, target ,targetType) <ol><li>删除<code>user</code>、<code>target</code>、<code>targetType</code>对应的一则或多则记录</li></ol></li><li>getSubscriptionConfig(userID) <ol><li>查询SubscriptionConfig表，获取用户的订阅配置</li></ol></li><li>updateSubscriptionConfig(userID) <ol><li>更新用户的SubscriptionConfig记录</li></ol></li><li>getUserNotify(userID) <ol><li>获取用户的消息列表</li></ol></li><li>read(user, notifyIDs) <ol><li>更新指定的notify，把isRead属性设置为true</li></ol></li></ul><h2 id="_3-各场景发送逻辑" tabindex="-1"><a class="header-anchor" href="#_3-各场景发送逻辑" aria-hidden="true">#</a> 3. 各场景发送逻辑</h2><h3 id="_3-1-提醒的订阅、创建、拉取" tabindex="-1"><a class="header-anchor" href="#_3-1-提醒的订阅、创建、拉取" aria-hidden="true">#</a> 3.1 提醒的订阅、创建、拉取</h3><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/blogimage-master/image-20211103151303897.png" alt="image-20211103151303897" tabindex="0" loading="lazy"><figcaption>image-20211103151303897</figcaption></figure><ol><li>我们可以在产品创建之后，调用<code>NotifyService.subscribe</code>方法，</li><li>然后在产品被评论之后调用<code>NotifyService.createRemind</code>方法，</li><li>再就是用户登录系统或者其他的某一个时刻调</li><li>用<code>NotifyService.pullRemind</code>方法， 最后在用户查询消息队列的时候调用<code>NotifyService.getUserNotify</code>方法。</li></ol><h3 id="_3-2-公告的创建、拉取" tabindex="-1"><a class="header-anchor" href="#_3-2-公告的创建、拉取" aria-hidden="true">#</a> 3.2 公告的创建、拉取</h3><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/blogimage-master/image-20211103151351090.png" alt="image-20211103151351090" tabindex="0" loading="lazy"><figcaption>image-20211103151351090</figcaption></figure><ol><li>在管理员发送了一则公告的时候，调用<code>NotifyService.createAnnounce</code>方法，</li><li>然后在用户登录系统或者其他的某一个时刻调用<code>NotifyService.pullAnnounce</code>方法，</li><li>最后在用户查询消息队列的时候调用<code>NotifyService.getUserNotify</code>方法。</li></ol><h3 id="_3-3-信息的创建" tabindex="-1"><a class="header-anchor" href="#_3-3-信息的创建" aria-hidden="true">#</a> 3.3 信息的创建</h3><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/blogimage-master/image-20211103151524274.png" alt="image-20211103151524274" tabindex="0" loading="lazy"><figcaption>image-20211103151524274</figcaption></figure><p>信息的创建，只需要直接调用<code>NotifyService.createMessage</code>方法就可以了， 在下一次用户查询消息队列的时候，就会查询这条信息。</p><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>',18),g={href:"https://www.jianshu.com/p/6bf8166b291c",target:"_blank",rel:"noopener noreferrer"};function f(h,u){const i=n("ExternalLinkIcon");return l(),a("div",null,[d,e("p",null,[e("a",g,[t("消息系统设计与实现「下篇」"),r(i)])])])}const y=o(s,[["render",f],["__file","message-system-process.html.vue"]]);export{y as default};
