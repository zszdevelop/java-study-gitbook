import{_ as t,W as r,X as s,Y as i,Z as e,$ as l,a0 as n,D as p}from"./framework-0cf5f349.js";const o={},g=n('<h1 id="jmeter监听器" tabindex="-1"><a class="header-anchor" href="#jmeter监听器" aria-hidden="true">#</a> JMeter监听器</h1><h2 id="_1-简介" tabindex="-1"><a class="header-anchor" href="#_1-简介" aria-hidden="true">#</a> 1. 简介</h2><p>监听器用来监听及显示JMeter取样器测试结果，能够以树、表及图形形式显示测试结果，也可以以文件方式保存测试结果，JMeter测试结果文件格式多样，比如XML格式、CSV格式。默认情况下，测试结果将被存储为xml格式的文件，文件的后缀: &quot;.jtl&quot;。另外一种存储格式为CSV文件，该格式的好处就是效率更高，但存储的信息不如xml格式详细。</p><h2 id="_2-预览监听器" tabindex="-1"><a class="header-anchor" href="#_2-预览监听器" aria-hidden="true">#</a> 2. 预览监听器</h2><p>首先我们来看一下JMeter的监听器，路径：线程组（用户）-&gt;添加-&gt;监听器；我们可以清楚地看到JMeter5中共有16个监听器（不包括jp@gc开头的监听器，这个是安装的插件），如下图所示：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220624144312399.png" alt="image-20220624144312399" tabindex="0" loading="lazy"><figcaption>image-20220624144312399</figcaption></figure><h2 id="_3-常用监听器详解" tabindex="-1"><a class="header-anchor" href="#_3-常用监听器详解" aria-hidden="true">#</a> 3.常用监听器详解</h2><p>这一小节，宏哥就<strong>由上而下</strong>地详细地讲解一下常用的监听器。</p><h3 id="_3-1-察看结果树-重要" tabindex="-1"><a class="header-anchor" href="#_3-1-察看结果树-重要" aria-hidden="true">#</a> 3.1 察看结果树(重要)</h3><p>察看结果树，显示取样器请求和响应的细节以及请求结果，包括消息头，请求的数据，响应的数据。</p><p>注意！！！敲黑板，敲脑壳！！！</p><ol><li><p>察看结果树，放的位置不同，查看的结果也不同。在线程组下添加察看结果树，查看线程组下所有请求的结果；放在具体某个请求下，只查看此请求的结果；若放在某个控制器节点下，则查看此控制器下节点执行的结果；</p></li><li><p><strong>该监听器推荐做调试用，在实际运行压测时，应该禁用</strong>，因为大量请求时，启用该监听器时打印的日志比较多，会造成大IO消耗，影响压力机性能。</p></li></ol><h4 id="_3-1-1-初识" tabindex="-1"><a class="header-anchor" href="#_3-1-1-初识" aria-hidden="true">#</a> 3.1.1 初识</h4><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220627134225505.png" alt="image-20220627134225505" tabindex="0" loading="lazy"><figcaption>image-20220627134225505</figcaption></figure><h4 id="_3-1-2-关键参数说明如下" tabindex="-1"><a class="header-anchor" href="#_3-1-2-关键参数说明如下" aria-hidden="true">#</a> 3.1.2 关键参数说明如下：</h4><ul><li><p>**名称：**控制器的描述性名称，显示在左边节点上，并用于命名事务</p></li><li><p>**注释：**控制器注释信息，非必填项</p></li><li><p>**文件名：**载入文件名</p></li><li><p><strong>Log/Display Only:</strong> 仅日志错误、Success ；勾选中显示对应的日志信息</p></li><li><p>**Configure：**定义report中自己所关心的数据项。</p></li><li><p><strong>取样器结果：</strong></p><ul><li>Thread Name: 线组名称</li><li>Sample Start: 启动开始时间</li><li>Load time: 加载时长</li><li>Latency: 等待时长</li><li>Size in bytes: 发送的数据总大小</li><li>Headers size in bytes: 发送头大小</li><li>Body size in bytes: 发送数据的其余部分大小</li><li>Sample Count: 发送统计</li><li>Error Count: 错误统计</li><li>Response code: 返回码</li><li>Response message: 返回消息</li><li>Response headers:返回头信息</li></ul></li><li><p><strong>请求</strong> 　数据获取方式、路径、地址等以及传递的参数、cookie</p></li><li><p><strong>响应数据</strong> 　响应加载的页面html</p></li></ul><h4 id="_3-1-3-作用" tabindex="-1"><a class="header-anchor" href="#_3-1-3-作用" aria-hidden="true">#</a> 3.1.3 作用</h4><ol><li><p>查看请求结果，请求成功的测试通常为绿色；红色则代表失败。</p><blockquote><p><strong>注：在没有对请求断言的情况下，显示绿色并不一定是成功，只代表响应码是200或300系列，显示红色说明响应码是400或500系列。所以要想确定请求返回的是正确的，必须要加上断言，只有断言成功才会显示绿色。</strong></p></blockquote></li><li><p>查看对应Sampler的测试结果的请求、响应数据。</p><ul><li><p>取样器结果：显示的是取样器相关参数（客户端参数与响应参数）</p></li><li><p>请求：发送请求的具体内容</p></li><li><p>响应数据：服务器返回的相应参数</p></li></ul></li></ol><h3 id="_3-2-汇总报告" tabindex="-1"><a class="header-anchor" href="#_3-2-汇总报告" aria-hidden="true">#</a> 3.2 汇总报告</h3><p>汇总报告，为测试中的每个不同命名的请求创建一个表行。这与聚合报告类似，只是它使用更少的内存。提供了最简要的测试结果信息，同时可以配置将相应的信息保存至指定的文件中（支持xml、csv格式的文件）。</p><p>单击Configure按钮，可以配置结果保存各种选项，具体这里不做说明了。</p><p>该监听器是笔者在调试jmeter项目时常用的监听器之一。</p><h4 id="_3-2-1-初识" tabindex="-1"><a class="header-anchor" href="#_3-2-1-初识" aria-hidden="true">#</a> 3.2.1 初识</h4><p>路径：<strong>线程组 &gt; 添加 &gt; 监听器 &gt; 汇总报告</strong>，如下图所示：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220627135254375.png" alt="image-20220627135254375" tabindex="0" loading="lazy"><figcaption>image-20220627135254375</figcaption></figure><h4 id="_3-2-2-关键参数说明如下" tabindex="-1"><a class="header-anchor" href="#_3-2-2-关键参数说明如下" aria-hidden="true">#</a> 3.2.2 关键参数说明如下：</h4><ul><li><p>**Name：**名称，可以随意设置，甚至为空；</p></li><li><p>**Comments：**注释，可随意设置，可以为空；</p></li><li><p><strong>Label 取样器别名</strong>，如果勾选Include group name ，则会添加线程组的名称作为前缀</p></li><li><p><strong># Samples</strong> 取样器运行次数</p><ul><li><p><strong>Average</strong> 请求（事务）的平均响应时间</p></li><li><p><strong>Min</strong> 请求的最小响应时间</p></li><li><p><strong>Max</strong> 请求的最大响应时间</p></li><li><p><strong>Std. Dev</strong> 响应时间的标准方差</p></li><li><p><strong>Error %</strong> 事务错误率</p></li><li><p><strong>Throughput</strong> 吞吐量 也就是TPS</p></li><li><p><strong>Received KB/sec</strong> 每秒收到的千字节</p></li><li><p><strong>Sent KB/sec</strong> 每秒发送的千字节</p></li><li><p><strong>Avg. Bytes</strong> 响应平均流量</p></li></ul></li></ul><h3 id="_3-3-聚合报告" tabindex="-1"><a class="header-anchor" href="#_3-3-聚合报告" aria-hidden="true">#</a> 3.3 聚合报告</h3><p>聚合报告，记录这次性能测试的总请求数、错误率、用户响应时间（中间值、90%、最少、最大）、吞吐量等，用以帮助分析被测试系统的性能。在聚合报告中，各个响应时间不能超过客户的要求，就是合格，例如不能超过响应时间2s，大于2s就是不合格的.</p><p><strong>聚合报告应该是最详细的报告了，也是最为常用的报告</strong>。是大家在压测过程中最常用的监听器。</p><p>该监听器对于每个请求，它统计响应信息并提供请求数，平均值，最大，最小值，中位数、90%、95%、错误率，吞吐量(以请求数/秒为单位)和以kb/秒为单位的吞吐量。</p><p>单击Configure按钮，可以配置结果保存各种选项，具体这里不做说明了。</p><h4 id="_3-3-1-初识" tabindex="-1"><a class="header-anchor" href="#_3-3-1-初识" aria-hidden="true">#</a> 3.3.1 初识</h4><p>路径：<strong>线程组 &gt; 添加 &gt; 监听器 &gt; 聚合报告</strong>，如下图所示：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220627135805197.png" alt="image-20220627135805197" tabindex="0" loading="lazy"><figcaption>image-20220627135805197</figcaption></figure><h4 id="_3-3-2-关键参数说明如下" tabindex="-1"><a class="header-anchor" href="#_3-3-2-关键参数说明如下" aria-hidden="true">#</a> 3.3.2 关键参数说明如下：</h4><ul><li><p>**Name：**名称，可以随意设置，甚至为空；</p></li><li><p>**Comments：**注释，可随意设置，可以为空；</p></li><li><p>**Label ：**每个 JMeter 的 element（例如 HTTP Request）都有一个 Name 属性，这里显示的就是 Name 属性的值</p></li><li><p>**#Samples ：**表示测试中一共发出了多少个请求，如果模拟10个用户，每个用户迭代10次，那么这里就显示对应的 HTTP Request的执行次数是100</p><ul><li><p>**Average ：**平均响应时间——默认情况下是单个 Request 的平均响应时间，当使用了 Transaction Controller 时，也可以以Transaction 为单位显示平均响应时间</p></li><li><p>**Median ：**50%用户的响应时间</p></li><li><p>**90%Line ：**90%用户的响应时间</p></li><li><p>**Min ：**最少响应时间</p></li><li><p>**Max ：**最大响应时间</p></li><li><p>**Error% ：**本次运行测试中出现错误的请求的数量/请求的总数</p></li><li><p>**Throughput ：**吞吐量，默认情况下表示每秒完成的请求数（Request per Second），当使用了 Transaction Controller 时，也可以表示类似 LoadRunner 的 Transaction per Second 数</p></li><li><p>**（接收/发送）KB/sec ：**每秒从服务器端接收到的数据量，相当于LoadRunner中的Throughput/Sec</p></li></ul></li></ul><h3 id="_3-4-后端监听器" tabindex="-1"><a class="header-anchor" href="#_3-4-后端监听器" aria-hidden="true">#</a> 3.4 后端监听器</h3><p>后端监听器，是一个异步侦听器，可以将数据推入都数据库中，提供了InfluxDB，graphite选项</p><h4 id="_3-4-1-初识" tabindex="-1"><a class="header-anchor" href="#_3-4-1-初识" aria-hidden="true">#</a> 3.4.1 初识</h4><p>我们先来看看这个 <strong>后端监听器</strong> 长得是啥样子，路径：<strong>线程组 &gt; 添加 &gt; 监听器 &gt; 后端监听器</strong>，如下图所示：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220627140124266.png" alt="image-20220627140124266" tabindex="0" loading="lazy"><figcaption>image-20220627140124266</figcaption></figure><h4 id="_3-4-2-关键参数说明如下" tabindex="-1"><a class="header-anchor" href="#_3-4-2-关键参数说明如下" aria-hidden="true">#</a> 3.4.2 关键参数说明如下：</h4><ul><li><p>**Name：**名称，可以随意设置，甚至为空；</p></li><li><p>**Comments：**注释，可随意设置，可以为空；</p></li><li><p>**Backend Listener implementation：**BackendListenerClient类的实现，Jmeter默认提供如下两种实现，因为我们使用的influxdb作为持久存储</p></li></ul><p>​ org.apache.jmeter.visualizers.backend.graphite.GraphiteBackendListenerClient</p><ul><li><p><strong>org.apache.jmeter.visualizers.backend.graphite.InfluxdbBackendListenerClient 因为我们使用的influxdb作为持久存储，所以后续只介绍InfluxdbBackendListenerClient</strong></p></li><li><p>**Async Queue size：**异步队列大小 队列值包含异步处理时的度量标准。除非有一些特定的性能问题，否则最好不要从默认的5000。</p></li></ul><h3 id="_3-5-汇总图" tabindex="-1"><a class="header-anchor" href="#_3-5-汇总图" aria-hidden="true">#</a> 3.5 汇总图</h3><p>汇总图，我们可以看到表格显示的结果与图形结果，看着挺复杂，其实稍微翻译一下就知道，绝大多数都是对图形的设置。</p><h4 id="_3-5-1-初识" tabindex="-1"><a class="header-anchor" href="#_3-5-1-初识" aria-hidden="true">#</a> 3.5.1 初识</h4><p>路径：<strong>线程组 &gt; 添加 &gt; 监听器 &gt; 汇总图</strong>，如下图所示：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220627140314269.png" alt="image-20220627140314269" tabindex="0" loading="lazy"><figcaption>image-20220627140314269</figcaption></figure><h4 id="_3-5-2-关键参数说明如下" tabindex="-1"><a class="header-anchor" href="#_3-5-2-关键参数说明如下" aria-hidden="true">#</a> 3.5.2 关键参数说明如下：</h4><ul><li><p>**Name：**名称，可以随意设置，甚至为空；</p></li><li><p>**Comments：**注释，可随意设置，可以为空；</p></li><li><p><strong>Column settings</strong></p><ul><li><p>Columns to display 选择要在图表中显示的列</p></li><li><p>Rectangles color 单击右侧颜色矩形打开弹出对话框，选择自定义颜色。</p><p>就是点击<img src="https://ask.qcloudimg.com/http-save/yehe-5695339/tyvshlpsy6.png?imageView2/2/w/1620" alt="img" loading="lazy">)</p></li><li><p>Foreground color 允许更改值文本颜色</p></li><li><p>Value font 允许定义文本的字体设置</p></li><li><p>Draw outlines bar? 在条形图上绘制或不绘制边界线</p></li><li><p>Show number grouping? 是否显示Y轴标签中的数字分组</p></li><li><p>Value labels vertical? 更改值标签的方向。（默认为水平）</p></li><li><p>Column label selection 按结果标签过滤</p></li></ul></li><li><p><strong>Title</strong></p></li></ul><p>​ 在图表的头部定义图表的标题</p><ul><li><strong>Graph size</strong></li></ul><p>​ 根据当前JMeter窗口大小的宽度和高度计算图形大小。使用“ 宽度”和“ 高度”字段定义自定义大小。单位是像素。</p><ul><li><strong>X Axis settings</strong></li></ul><p>定义X轴标签的最大长度（以像素为单位）</p><ul><li><strong>Y Axis settings</strong></li></ul><p>为Y轴定义自定义最大值。</p><ul><li><strong>Legend</strong></li></ul><p>定义图表图例的放置和字体设置</p><h3 id="_3-6-断言结果" tabindex="-1"><a class="header-anchor" href="#_3-6-断言结果" aria-hidden="true">#</a> 3.6 断言结果</h3><p>断言结果，对相应的请求添加断言。对取样器进行断言后，我们希望知道断言结果；此元件可以帮助我们显示断言结果（察看结果树元件中也可以看到）。消耗了大量资源（内存和CPU），性能测试时候不建议使用。</p><p>作用：用于检查测试中得到的响应数据等是否符合预期，用以保证性能测试过程中的数据交互与预期一致，一般与结果树结合使用。</p><h4 id="_3-6-1-初识" tabindex="-1"><a class="header-anchor" href="#_3-6-1-初识" aria-hidden="true">#</a> 3.6.1 初识</h4><p>路径：<strong>线程组 &gt; 添加 &gt; 监听器 &gt; 断言结果</strong>，如下图所示：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220627143235052.png" alt="image-20220627143235052" tabindex="0" loading="lazy"><figcaption>image-20220627143235052</figcaption></figure><h4 id="_3-6-2-关键参数说明如下" tabindex="-1"><a class="header-anchor" href="#_3-6-2-关键参数说明如下" aria-hidden="true">#</a> 3.6.2 关键参数说明如下：</h4><ul><li><p>**Name：**名称，可以随意设置，甚至为空；</p></li><li><p>**Comments：**注释，可随意设置，可以为空。</p></li></ul><h3 id="_3-7-比较断言可视化器" tabindex="-1"><a class="header-anchor" href="#_3-7-比较断言可视化器" aria-hidden="true">#</a> 3.7 比较断言可视化器</h3><p>比较断言可视化器，和比较断言配合使用。</p><h4 id="_3-7-1-初识" tabindex="-1"><a class="header-anchor" href="#_3-7-1-初识" aria-hidden="true">#</a> 3.7.1 初识</h4><p>路径：<strong>线程组 &gt; 添加 &gt; 监听器 &gt; 比较断言可视化器</strong>，如下图所示：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220627143409980.png" alt="image-20220627143409980" tabindex="0" loading="lazy"><figcaption>image-20220627143409980</figcaption></figure><h4 id="_3-7-2-关键参数说明如下" tabindex="-1"><a class="header-anchor" href="#_3-7-2-关键参数说明如下" aria-hidden="true">#</a> 3.7.2 关键参数说明如下：</h4><ul><li><p>**Name：**名称，可以随意设置，甚至为空；</p></li><li><p>**Comments：**注释，可随意设置，可以为空。</p></li></ul><h3 id="_3-8-生成概要结果" tabindex="-1"><a class="header-anchor" href="#_3-8-生成概要结果" aria-hidden="true">#</a> 3.8 生成概要结果</h3><p>生成概要结果，该测试元素可以放置在测试计划中的任何位置。生成到目前为止对日志文件和/或标准输出的测试运行的摘要。显示了运行总计和差异总计。在适当的时间边界每n秒（默认为30秒）生成一次输出，因此将同步在同一时间运行的多个测试。</p><h4 id="_3-8-1-初识" tabindex="-1"><a class="header-anchor" href="#_3-8-1-初识" aria-hidden="true">#</a> 3.8.1 初识</h4><p>路径：<strong>线程组 &gt; 添加 &gt; 监听器 &gt; 生成概要结果</strong>，如下图所示：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220627143515680.png" alt="image-20220627143515680" tabindex="0" loading="lazy"><figcaption>image-20220627143515680</figcaption></figure><h4 id="_3-8-2-关键参数说明如下" tabindex="-1"><a class="header-anchor" href="#_3-8-2-关键参数说明如下" aria-hidden="true">#</a> 3.8.2 关键参数说明如下：</h4><ul><li><p>**Name：**名称，可以随意设置，甚至为空；</p></li><li><p>**Comments：**注释，可随意设置，可以为空。</p></li></ul><h3 id="_3-9-图形结果" tabindex="-1"><a class="header-anchor" href="#_3-9-图形结果" aria-hidden="true">#</a> 3.9 图形结果</h3><p>图形结果，通过图形展示出本次性能测试数据的分布。 图形结果一般作为聚合报告的分析辅佐</p><h4 id="_3-9-1-初识" tabindex="-1"><a class="header-anchor" href="#_3-9-1-初识" aria-hidden="true">#</a> 3.9.1 初识</h4><p>路径：<strong>线程组 &gt; 添加 &gt; 监听器 &gt; 图形结果</strong>，如下图所示：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220627144201869.png" alt="image-20220627144201869" tabindex="0" loading="lazy"><figcaption>image-20220627144201869</figcaption></figure><h4 id="_3-9-2-关键参数说明如下" tabindex="-1"><a class="header-anchor" href="#_3-9-2-关键参数说明如下" aria-hidden="true">#</a> 3.9.2 关键参数说明如下：</h4>',90),h=i("li",null,[i("p",null,"**名称：**控制器的描述性名称，显示在左边节点上，并用于命名事务")],-1),d=i("li",null,[i("p",null,"**注释：**控制器注释信息，非必填项")],-1),c=i("p",null,"**文件名：**载入文件名",-1),u=i("p",null,"Throught：吞吐量，可以理解成TPS（TPS表示每秒通过的事物数，QPS表示每秒查询接口数。jmeter中如果只有单接口，那么TPS=QPS。如果是多接口的混合场景，只有在事物控制器下执行，才能将其理解为TPS）",-1),m={href:"https://cloud.tencent.com/product/cvm?from=10680",target:"_blank",rel:"noopener noreferrer"},_=i("li",null,[i("p",null,"最新样本。jmeter最后一次发送请求的响应时间。单位是毫秒；")],-1),b=i("li",null,[i("p",null,"平均。所有请求响应时间的平均值。单位是毫秒；")],-1),f=i("li",null,[i("p",null,"偏离。标准方差，学过统计学的同学应该知道这个概念。如果你对这个概念一无所知也没有关系，偏离越小就代表测试的总体结果与平均值越接近；")],-1),x=i("li",null,[i("p",null,"吞吐量。被测系统每分钟能处理的请求个数，这是判断服务器性能好坏的重要指标（也可以说是最重要的指标）。在上面的图形结果报表里我们可以看到系统的吞吐量是138.985每分钟，这就代表着系统每分钟可以处理138.985个请求；")],-1),z=i("li",null,[i("p",null,"中值。就是响应时间的中间值，学术一点中值指的是有50%的值大于这个值，另外50%的值小于这个值。蒙圈了吧？实际上中值指的是如果有9个数，那么我们从小到大排列这些数，排在第5个的数就是这一组数的中值。那么如果有10个数呢？10个数的话第5个和第6个数的平均值就是这组数字的中值；")],-1),y=n('<h3 id="_3-10-响应时间图" tabindex="-1"><a class="header-anchor" href="#_3-10-响应时间图" aria-hidden="true">#</a> 3.10 响应时间图</h3><p>响应时间图，响应时间图形监听器。有点和我们之前介绍的<strong>Aggregate Graph</strong>类似</p><h4 id="_3-10-1-初识" tabindex="-1"><a class="header-anchor" href="#_3-10-1-初识" aria-hidden="true">#</a> 3.10.1 初识</h4><p>路径：<strong>线程组 &gt; 添加 &gt; 监听器 &gt; 响应时间图</strong>，如下图所示：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220627144418037.png" alt="image-20220627144418037" tabindex="0" loading="lazy"><figcaption>image-20220627144418037</figcaption></figure><h4 id="_3-10-2-关键参数说明如下" tabindex="-1"><a class="header-anchor" href="#_3-10-2-关键参数说明如下" aria-hidden="true">#</a> 3.10.2 关键参数说明如下：</h4><ul><li><p>**Name：**名称，可以随意设置，甚至为空；</p></li><li><p>**Comments：**注释，可随意设置，可以为空；</p></li><li><p>Graph setting 图片设置</p></li><li><p>Interval：横坐标的刻度</p></li><li><p>Title 标题 默认</p></li><li><p>Line setting 线条设置 默认</p></li><li><p>Graph size 图片尺寸 默认</p></li><li><p>X Axis 横坐标 默认</p></li><li><p>Y Aixs 纵坐标</p></li><li><p>Scale maximum value 纵坐标长度</p></li><li><p>increment scale 纵坐标的刻度 ；Legend 字体设置 默认</p><ul><li><p>Interval (ms) X轴间隔的时间（以毫秒为单位）</p></li><li><p>Sampler label selection 按结果标签过滤。可以使用正则表达式</p></li><li><p>Title 在图表的头部定义图表的标题</p></li><li><p>Line settings 定义线条的宽度</p></li><li><p>Graph size 根据当前JMeter窗口大小的宽度和高度计算图形大小。使用“ 宽度”和“ 高度”字段定义自定义大小。单位是像素。</p></li><li><p>X Axis settings 自定义X轴标签的日期格式</p></li><li><p>Y Axis settings 为Y轴定义自定义最大值（以毫秒为单位）</p></li><li><p>Legend 定义图表图例的放置和字体设置</p></li></ul></li></ul><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>',8),C={href:"https://cloud.tencent.com/developer/inventory/1923/article/1677830",target:"_blank",rel:"noopener noreferrer"};function S(j,v){const a=p("ExternalLinkIcon");return r(),s("div",null,[g,i("ul",null,[h,d,i("li",null,[c,u,i("ul",null,[i("li",null,[i("p",null,[e("样本数目。在这里，我们可以把样本数量简单理解成是jmeter一共向"),i("a",m,[e("服务器"),l(a)]),e("发起了多少次请求；")])]),_,b,f,x,z])])]),y,i("p",null,[i("a",C,[e("Jmeter(十九) - 从入门到精通 - JMeter监听器"),l(a)])])])}const T=t(o,[["render",S],["__file","dev-y-pu-jmeter-listener.html.vue"]]);export{T as default};
