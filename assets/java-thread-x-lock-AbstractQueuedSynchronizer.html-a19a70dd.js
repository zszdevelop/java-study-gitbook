const e=JSON.parse('{"key":"v-7a75b5c4","path":"/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html","title":"JUC锁: 锁核心类AQS详解","lang":"zh-CN","frontmatter":{"order":540,"category":["Java","并发"],"description":"0. 面试题 什么是AQS? 为什么它是核心?; AQS的核心思想是什么? 它是怎么实现的? 底层数据结构等; AQS有哪些核心的方法?; AQS定义什么样的资源获取方式? AQS定义了两种资源获取方式：独占(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和`非公平锁，如ReentrantLock) 和共享(多个线程可同时访问执行，如Sema...","head":[["meta",{"property":"og:url","content":"https://zszdevelop.github.io/java-study-gitbook/java-study-gitbook/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html"}],["meta",{"property":"og:site_name","content":"Java学习笔记"}],["meta",{"property":"og:title","content":"JUC锁: 锁核心类AQS详解"}],["meta",{"property":"og:description","content":"0. 面试题 什么是AQS? 为什么它是核心?; AQS的核心思想是什么? 它是怎么实现的? 底层数据结构等; AQS有哪些核心的方法?; AQS定义什么样的资源获取方式? AQS定义了两种资源获取方式：独占(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和`非公平锁，如ReentrantLock) 和共享(多个线程可同时访问执行，如Sema..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-02-20T13:42:31.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-02-20T13:42:31.000Z"}]]},"headers":[{"level":2,"title":"0. 面试题","slug":"_0-面试题","link":"#_0-面试题","children":[]},{"level":2,"title":"1. AbstractQueuedSynchronizer简介","slug":"_1-abstractqueuedsynchronizer简介","link":"#_1-abstractqueuedsynchronizer简介","children":[]},{"level":2,"title":"2. AQS 核心思想","slug":"_2-aqs-核心思想","link":"#_2-aqs-核心思想","children":[]},{"level":2,"title":"3. AQS 对资源的共享方式","slug":"_3-aqs-对资源的共享方式","link":"#_3-aqs-对资源的共享方式","children":[]},{"level":2,"title":"4. AQS底层使用了模板方法模式","slug":"_4-aqs底层使用了模板方法模式","link":"#_4-aqs底层使用了模板方法模式","children":[]},{"level":2,"title":"5. AQS数据结构","slug":"_5-aqs数据结构","link":"#_5-aqs数据结构","children":[]},{"level":2,"title":"6. AQS源码分析","slug":"_6-aqs源码分析","link":"#_6-aqs源码分析","children":[{"level":3,"title":"6.1 类的继承关系","slug":"_6-1-类的继承关系","link":"#_6-1-类的继承关系","children":[]},{"level":3,"title":"6.2 类的内部类 - Node类","slug":"_6-2-类的内部类-node类","link":"#_6-2-类的内部类-node类","children":[]},{"level":3,"title":"6.3 类的内部类 - ConditionObject类","slug":"_6-3-类的内部类-conditionobject类","link":"#_6-3-类的内部类-conditionobject类","children":[]},{"level":3,"title":"6.4 类的属性","slug":"_6-4-类的属性","link":"#_6-4-类的属性","children":[]},{"level":3,"title":"6.5 类的构造方法","slug":"_6-5-类的构造方法","link":"#_6-5-类的构造方法","children":[]},{"level":3,"title":"6.6 类的核心方法 - acquire方法","slug":"_6-6-类的核心方法-acquire方法","link":"#_6-6-类的核心方法-acquire方法","children":[]},{"level":3,"title":"6.7 类的核心方法 - release方法","slug":"_6-7-类的核心方法-release方法","link":"#_6-7-类的核心方法-release方法","children":[]}]},{"level":2,"title":"7. AbstractQueuedSynchronizer总结","slug":"_7-abstractqueuedsynchronizer总结","link":"#_7-abstractqueuedsynchronizer总结","children":[]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1676900551000,"updatedTime":1676900551000,"contributors":[{"name":"zszdevelop","email":"zszdevelop@163.com","commits":1}]},"readingTime":{"minutes":25.79,"words":7738},"filePathRelative":"java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.md","localizedDate":"2023年2月20日","autoDesc":true}');export{e as data};
