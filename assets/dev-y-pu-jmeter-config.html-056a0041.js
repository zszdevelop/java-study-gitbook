import{_ as d,W as n,X as r,Y as t,Z as e,$ as l,a0 as i,D as s}from"./framework-0cf5f349.js";const g={},h=i('<h1 id="jmeter配置元件" tabindex="-1"><a class="header-anchor" href="#jmeter配置元件" aria-hidden="true">#</a> JMeter配置元件</h1><h2 id="_1-简介" tabindex="-1"><a class="header-anchor" href="#_1-简介" aria-hidden="true">#</a> <strong>1. 简介</strong></h2><p>JMeter配置元件可以用来初始化默认值和变量，读取文件数据，设置公共请求参数，赋予变量值等，以便后续采样器使用。将在其作用域的初始化阶段处理。配置元件（Config Element）提供对静态数据配置的支持，可以为取样器设置默认值和变量。</p><h3 id="_1-1-添加配置元件" tabindex="-1"><a class="header-anchor" href="#_1-1-添加配置元件" aria-hidden="true">#</a> 1.1 添加配置元件</h3><p>首先我们来看一下JMeter的配置元件，路径：添加-配置元件；我们可以清楚地看到JMeter5中共有19个配置元件，如下图所示：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623154721019.png" alt="image-20220623154721019" tabindex="0" loading="lazy"><figcaption>image-20220623154721019</figcaption></figure><h2 id="_2-常用配置元件详解" tabindex="-1"><a class="header-anchor" href="#_2-常用配置元件详解" aria-hidden="true">#</a> 2.常用配置元件详解</h2><p>这一小节，宏哥就<strong>由上而下</strong>地详细地讲解一下常用的配置元件。</p><h3 id="_2-1-csv-data-set-config" tabindex="-1"><a class="header-anchor" href="#_2-1-csv-data-set-config" aria-hidden="true">#</a> 2.1 CSV Data Set Config</h3><h4 id="_2-1-1-初识" tabindex="-1"><a class="header-anchor" href="#_2-1-1-初识" aria-hidden="true">#</a> 2.1.1 初识</h4><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623154830681.png" alt="image-20220623154830681" tabindex="0" loading="lazy"><figcaption>image-20220623154830681</figcaption></figure><h4 id="_2-1-2-参数详解及说明" tabindex="-1"><a class="header-anchor" href="#_2-1-2-参数详解及说明" aria-hidden="true">#</a> 2.1.2 参数详解及说明，</h4><p>如下表所示：</p><table><thead><tr><th style="text-align:left;">参 数</th><th style="text-align:left;">描 述</th><th style="text-align:left;">是否必填</th></tr></thead><tbody><tr><td style="text-align:left;">Name</td><td style="text-align:left;">脚本中显示的这个元件的描述性名称</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">Filename</td><td style="text-align:left;">待读取文件的名称。可以写入绝对路径，也可以写入相对路径（相对于bin目录），如果直接写文件名，则该文件要放在bin目录中。对于分布式测试，主机和远程机中相应目录下应该有相同的CSV文件</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">File Encoding</td><td style="text-align:left;">文件读取时的编码格式，不填则使用操作系统的编码格式</td><td style="text-align:left;">否</td></tr><tr><td style="text-align:left;">Ignore first line</td><td style="text-align:left;">是否忽略首行，如果csv文件中没有表头，则选择false</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">Variable Names</td><td style="text-align:left;">变量名列表，多个变量名之间必须用分隔符分隔。如果该项为空，则文件首行会被读取并解析为列名列表</td><td style="text-align:left;">否</td></tr><tr><td style="text-align:left;">Delimiter</td><td style="text-align:left;">参数分隔符，将一行数据分隔成多个变量，默认为逗号，也可以使用“\\t”。如果一行数据分隔后的值比Vairable Names中定义的变量少，这些变量将保留以前的值（如果有值的话）</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">Allow quoted data?</td><td style="text-align:left;">是否允许变量使用双引号，允许的话，变量将可以括在双引号内，并且这些变量名可以包含分隔符</td><td style="text-align:left;">否</td></tr><tr><td style="text-align:left;">Recycle on EOF?</td><td style="text-align:left;">是否循环读取csv文件内容，达到文件结尾后，是否从文件开始循环重新读取；默认为 true</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">Stop thread on EOF?</td><td style="text-align:left;">是否循环读取csv文件内容，达到文件结尾后，线程是否该终止；默认为 true</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">Recycle on EOF?</td><td style="text-align:left;">当Recycle on EOF为False时，停止线程，当Recycle on EOF为True时，此项无意义，默认为 false</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">Sharing mode</td><td style="text-align:left;">1. All threads（默认）：一个线程组内，各个线程（用户）唯一顺序取值；2. current thread：一个线程组内，各个线程（用户）各自顺序取值；3、线程组各自独立，但每个线程组内各个线程（用户）唯一顺序取值；</td><td style="text-align:left;">是</td></tr></tbody></table><h4 id="_2-1-3-recycle-on-eof-和stop-thread-on-eof的关系" tabindex="-1"><a class="header-anchor" href="#_2-1-3-recycle-on-eof-和stop-thread-on-eof的关系" aria-hidden="true">#</a> 2.1.3 Recycle on EOF 和Stop thread on EOF的关系？</h4><ul><li>当Recycle on EOF 选择true时，Stop thread on EOF选择true和false无任何意义，因为既然前面已经设置了文件是不停的循环读取，后面的控制stop就相当于失效；</li><li>当Recycle on EOF 选择false时，Stop thread on EOF选择true，则当线程数超过文件里的参数的个数时，实际请求数为参数的个数；</li><li>当Recycle on EOF 选择false时，Stop thread on EOF选择flase，当线程数超过文件里参数的个数时，实际请求次数为线程数，但当线程数超过参数次数时，由于没有参数，所以结果仍然是失败的。</li></ul><h4 id="_2-1-4-sharing-mode" tabindex="-1"><a class="header-anchor" href="#_2-1-4-sharing-mode" aria-hidden="true">#</a> 2.1.4 Sharing mode</h4><p>如果希望每个线程拥有自己独立的值集合，那么就需要创建一系列数据文件，为每个线程准备一个数据文件，如test1.csv、test2.csv等，使用文件名test${__threadNum}.csv,并将“sharing mode&quot;设置为&quot;Current thread&quot;</p><ul><li><p>All threads：文件在所有线程间共享。</p></li><li><p>Identifier：所有线程共享相同的标识，共享相同的文件。如有４个线程组，测试人员可以使用一个通用ＩＤ，以便在两个或多个线程组之间共享文件。</p></li><li><p>Current thread：每个文件会针对每个线程单独打开。</p></li><li><p>Current thread group：每个文件会针对每个线程组打开一次。</p></li></ul><h3 id="_2-2-http-header-manager" tabindex="-1"><a class="header-anchor" href="#_2-2-http-header-manager" aria-hidden="true">#</a> 2.2 HTTP Header Manager</h3><p>支持用户添加或者重写HTTP请求头。JMeter支持多个信息头管理器。多个信息头条目合并成一个信息头列表，跟随http请求一并提交到服务端。</p><ol><li><p>当有多个信息头管理器，且不同的管理器内有名称相同的信息头条目存在时，顺序靠前的管理器的信息头条目会覆盖后面的；</p></li><li><p>当只有一个信息头管理器，但管理器内有名称相同的信息头条目时，会同时生效；</p></li></ol><h4 id="_2-2-1-初识" tabindex="-1"><a class="header-anchor" href="#_2-2-1-初识" aria-hidden="true">#</a> 2.2.1 初识</h4><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623155758985.png" alt="image-20220623155758985" tabindex="0" loading="lazy"><figcaption>image-20220623155758985</figcaption></figure><h4 id="_2-2-2-参数详解及说明" tabindex="-1"><a class="header-anchor" href="#_2-2-2-参数详解及说明" aria-hidden="true">#</a> 2.2.2 参数详解及说明</h4><p>如下表所示：</p><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:left;">描述</th><th style="text-align:left;">是否必填</th></tr></thead><tbody><tr><td style="text-align:left;">Name</td><td style="text-align:left;">请求头的名称，比如Content-Type</td><td style="text-align:left;">否</td></tr><tr><td style="text-align:left;">Value</td><td style="text-align:left;">请求头的值，比如application/json</td><td style="text-align:left;">否</td></tr></tbody></table><h4 id="_2-2-3-常用请求头" tabindex="-1"><a class="header-anchor" href="#_2-2-3-常用请求头" aria-hidden="true">#</a> 2.2.3 常用请求头</h4><p>这些一般可以抓包和在浏览器中查到，如下表所示：</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623155859879.png" alt="image-20220623155859879" tabindex="0" loading="lazy"><figcaption>image-20220623155859879</figcaption></figure><h3 id="_2-3-http-cookie-manager" tabindex="-1"><a class="header-anchor" href="#_2-3-http-cookie-manager" aria-hidden="true">#</a> 2.3 HTTP Cookie Manager</h3><p>主要有两个功能：</p><ul><li>一个功能是：像web浏览器一样存储和发送Cookie。如果有一个HTTP请求和相应里包含Cookie，Cookie管理器会自动存储Cookie，那么接下来针对特定web站点的所有请求中使用该Cookie。可在结果树中查看。</li></ul><p>接收到的Cookie可以被保存为变量，须定义属性&quot;CookieManager.save.cookie=true&quot;。另外，在被存储前Cookie名称会加上前缀“COOKIE_&quot;，要恢复早前处理方式，则定义属性”CookieManager.name.prefix=&quot;(一个或多个空格）。</p><p>如果启动了该功能，那么名称为TEST的Cookie,可以通过${COOKIE_TEST}加以引用。手动为Cookie管理器添加一个Cookie（为所有JMeter线程所共享）。</p><h4 id="_2-3-1-初识" tabindex="-1"><a class="header-anchor" href="#_2-3-1-初识" aria-hidden="true">#</a> 2.3.1 初识</h4><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623160045957.png" alt="image-20220623160045957" tabindex="0" loading="lazy"><figcaption>image-20220623160045957</figcaption></figure><h4 id="_2-3-2-参数详细说明" tabindex="-1"><a class="header-anchor" href="#_2-3-2-参数详细说明" aria-hidden="true">#</a> 2.3.2 参数详细说明</h4><p>如下表所示：</p><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:left;">描述</th><th style="text-align:left;">是否必填</th></tr></thead><tbody><tr><td style="text-align:left;">Name</td><td style="text-align:left;">树中显示此元件描述的名称</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">Comments</td><td style="text-align:left;">注释</td><td style="text-align:left;">否</td></tr><tr><td style="text-align:left;">Clear cookie each Iteration</td><td style="text-align:left;">每次线程组运行前，都会清楚cookie，但是如果是手动添加的cookie，不会被清除</td><td style="text-align:left;">否</td></tr><tr><td style="text-align:left;">Cookie Policy</td><td style="text-align:left;">选择Cookie的管理策略，建议选择兼容性，兼容性强</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">User Define cookie</td><td style="text-align:left;">用户自定义cookie</td><td style="text-align:left;">否</td></tr></tbody></table><h3 id="_2-4-http-cache-manager" tabindex="-1"><a class="header-anchor" href="#_2-4-http-cache-manager" aria-hidden="true">#</a> 2.4 HTTP Cache Manager</h3><p>被用来为其作用域内的HTTP请求提供缓存功能，如果“Use Cache-Control/Expires header When ...&quot;选中，那么会根据当前时间来选择，如果请求是”GET&quot;，而时间指向未来，那么采样器就会立即返回，而无须从远程服务器 请求URL,这样是为了模拟浏览器的操作，请注意Cache-Control头必须是“pulic”的，并且只有&quot;max-age&quot;终结选项会被处理，如果请求文档自从其被缓存以来没有发生任何改变，那么响应包体就会为空。</p><h4 id="_2-4-1-初识" tabindex="-1"><a class="header-anchor" href="#_2-4-1-初识" aria-hidden="true">#</a> 2.4.1 初识</h4><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623160216803.png" alt="image-20220623160216803" tabindex="0" loading="lazy"><figcaption>image-20220623160216803</figcaption></figure><h4 id="_2-4-2-参数详细说明" tabindex="-1"><a class="header-anchor" href="#_2-4-2-参数详细说明" aria-hidden="true">#</a> 2.4.2 参数详细说明</h4><p>如下表所示：</p><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:left;">描述</th><th style="text-align:left;">是否必填</th></tr></thead><tbody><tr><td style="text-align:left;">Name</td><td style="text-align:left;">树中显示此元件的描述性名称</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">Comments</td><td style="text-align:left;">注释</td><td style="text-align:left;">否</td></tr><tr><td style="text-align:left;">Clear Cache each iteration</td><td style="text-align:left;">如果选择此选项，则在线程开始时清除缓存。</td><td style="text-align:left;">否</td></tr><tr><td style="text-align:left;">Use Cache</td><td style="text-align:left;">如果选择此选项，则在线程开始时使用缓存。</td><td style="text-align:left;">否</td></tr><tr><td style="text-align:left;">Max Number</td><td style="text-align:left;">如果选择此选项，则在线程开始时最大缓存。</td><td style="text-align:left;">否</td></tr></tbody></table><h3 id="_2-5-http-request-defaults" tabindex="-1"><a class="header-anchor" href="#_2-5-http-request-defaults" aria-hidden="true">#</a> 2.5 HTTP Request Defaults</h3><p>在实际测试计划中，我们经常会碰到Http Sampler请求有较多的参数与配置会重复，每一个Http Sampler都单独设置的话比较浪费时间和精力，为了节省工作量，JMeter提供了HTTP Request Defaults元件，用来把这些重复的部分封装起来，一次设置多次使用。可以设定一些缺省值，假设有10个请求，访问域名 和端口都是一样的，那HTTP请求中就不再需要单独配置了，比较方便（增加脚本的移植性）。</p>',49),o={href:"http://example.com",target:"_blank",rel:"noopener noreferrer"},f=i('<h4 id="_2-5-1-初识" tabindex="-1"><a class="header-anchor" href="#_2-5-1-初识" aria-hidden="true">#</a> 2.5.1 初识</h4><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623160414799.png" alt="image-20220623160414799" tabindex="0" loading="lazy"><figcaption>image-20220623160414799</figcaption></figure><h4 id="_2-5-2-参数详细说明" tabindex="-1"><a class="header-anchor" href="#_2-5-2-参数详细说明" aria-hidden="true">#</a> 2.5.2 参数详细说明</h4><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:left;">描述</th><th style="text-align:left;">是否必填</th></tr></thead><tbody><tr><td style="text-align:left;">Name</td><td style="text-align:left;">用作标识一个取样器，建议使用一个见名知义的名称</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;">Comments</td><td style="text-align:left;">注释</td><td style="text-align:left;">否</td></tr><tr><td style="text-align:left;">Protocol</td><td style="text-align:left;">协议，向目标服务器发送HTTP请求时的协议，可以是http或者是Https</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">IP</td><td style="text-align:left;">HTTP请求发送的目标服务器名称或者IP地址</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Port Number</td><td style="text-align:left;">目标服务器端口</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Path</td><td style="text-align:left;">目标URL路径（不包括服务器地址和端口）</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Content encdoing</td><td style="text-align:left;">内容的编码方式</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Parameter</td><td style="text-align:left;">参数</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">body data</td><td style="text-align:left;">参数</td><td style="text-align:left;"></td></tr></tbody></table><h3 id="_2-6counter" tabindex="-1"><a class="header-anchor" href="#_2-6counter" aria-hidden="true">#</a> 2.6Counter</h3><p>计数器，顾名思义就是在测试执行过程中会记录迭代次数。可以在线程组任何位置创建，允许用户配置起点、最大值和增量。配置后，计数器将从起点循环到最大值，然后重新开始，直到线程结束。允许用户创建一个计数器，可在线程组中任何地方被引用。</p><h4 id="_2-6-1-初识" tabindex="-1"><a class="header-anchor" href="#_2-6-1-初识" aria-hidden="true">#</a> 2.6.1 初识</h4><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623160550620.png" alt="image-20220623160550620" tabindex="0" loading="lazy"><figcaption>image-20220623160550620</figcaption></figure><h4 id="_2-6-2-参数详细说明" tabindex="-1"><a class="header-anchor" href="#_2-6-2-参数详细说明" aria-hidden="true">#</a> 2.6.2 参数详细说明</h4><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:left;">描述</th><th style="text-align:left;">是否必填</th></tr></thead><tbody><tr><td style="text-align:left;">Name</td><td style="text-align:left;">控制器名称，可以随意设置</td><td style="text-align:left;">否</td></tr><tr><td style="text-align:left;">Comments</td><td style="text-align:left;">注释，可以随意设置</td><td style="text-align:left;">否</td></tr><tr><td style="text-align:left;">Starting value</td><td style="text-align:left;">启动，记录数量起始值</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Increment</td><td style="text-align:left;">递增，记录迭代次数步长，1后是2，步长就是1</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Maximum value</td><td style="text-align:left;">记录的最大值</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Number format</td><td style="text-align:left;">计算器格式，可以是数字，例如000000（6位长度，000,000（6位长度，3位间隔开）；字符加数字，例如CUST_000000（字符加6位数字 ）</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Exported Variable Name</td><td style="text-align:left;">引用变量名称，记数器记录的值可以存入的此引用名（变量），可供其他元件调用</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Track counter independently for each user</td><td style="text-align:left;">与每位用户独立的跟踪计数器，每个线程都有自己的计数器，相互不干扰</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Reset counter on each Thread Group Iteration</td><td style="text-align:left;">每次迭代复原计数器</td><td style="text-align:left;"></td></tr></tbody></table><h3 id="_2-7-dns-cache-manager" tabindex="-1"><a class="header-anchor" href="#_2-7-dns-cache-manager" aria-hidden="true">#</a> 2.7 DNS Cache Manager</h3><h3 id="_2-7-1-初识" tabindex="-1"><a class="header-anchor" href="#_2-7-1-初识" aria-hidden="true">#</a> 2.7.1 初识</h3><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623160659187.png" alt="image-20220623160659187" tabindex="0" loading="lazy"><figcaption>image-20220623160659187</figcaption></figure><h4 id="_2-7-2-参数详细说明" tabindex="-1"><a class="header-anchor" href="#_2-7-2-参数详细说明" aria-hidden="true">#</a> 2.7.2 参数详细说明</h4><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:left;">描述</th><th style="text-align:left;">是否必填</th></tr></thead><tbody><tr><td style="text-align:left;">Name</td><td style="text-align:left;">树中显示此元件的描述性名称</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Comments</td><td style="text-align:left;">注释</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Clear cache each iter</td><td style="text-align:left;">清除每个迭代的缓存，如果选择此选项，则每次启动新迭代时，都会清除每个线程的DNS缓存。</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Use System DNS resolver</td><td style="text-align:left;">使用系统DNS解析器；将使用系统DNS解析器。为了正确工作，请编辑 $ JAVA_HOME / jre / lib / security / java.security并添加networkaddress.cache.ttl = 0</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Use custom DNS resolver</td><td style="text-align:left;">使用自定义DNS解析器；将使用自定义DNS解析器（来自dnsjava库）。</td><td style="text-align:left;"></td></tr></tbody></table><h3 id="_2-8-ftp-request-defaults" tabindex="-1"><a class="header-anchor" href="#_2-8-ftp-request-defaults" aria-hidden="true">#</a> 2.8 FTP Request Defaults</h3><p>被用于设置FTP请求的默认值</p><h4 id="_2-8-1-初识" tabindex="-1"><a class="header-anchor" href="#_2-8-1-初识" aria-hidden="true">#</a> 2.8.1 初识</h4><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623160810169.png" alt="image-20220623160810169" tabindex="0" loading="lazy"><figcaption>image-20220623160810169</figcaption></figure><h3 id="_2-9-http-authorization-manager" tabindex="-1"><a class="header-anchor" href="#_2-9-http-authorization-manager" aria-hidden="true">#</a> 2.9 HTTP Authorization Manager</h3><p>HTTP认证是一种安全机制，在客户端、浏览器或者程序向服务器发起请求时，需要提供用户名和密码且验证通过（拿到凭证）才能继续发起交互。</p><h4 id="_2-9-1-初识" tabindex="-1"><a class="header-anchor" href="#_2-9-1-初识" aria-hidden="true">#</a> 2.9.1 初识</h4><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623160901657.png" alt="image-20220623160901657" tabindex="0" loading="lazy"><figcaption>image-20220623160901657</figcaption></figure><h3 id="_2-10-jdbc-connection-configuration" tabindex="-1"><a class="header-anchor" href="#_2-10-jdbc-connection-configuration" aria-hidden="true">#</a> 2.10 JDBC Connection Configuration</h3><h4 id="_2-10-1-初识" tabindex="-1"><a class="header-anchor" href="#_2-10-1-初识" aria-hidden="true">#</a> 2.10.1 初识</h4><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623160939734.png" alt="image-20220623160939734" tabindex="0" loading="lazy"><figcaption>image-20220623160939734</figcaption></figure><h3 id="_2-11-random-variable" tabindex="-1"><a class="header-anchor" href="#_2-11-random-variable" aria-hidden="true">#</a> 2.11 Random Variable</h3><h4 id="_2-11-1-初始" tabindex="-1"><a class="header-anchor" href="#_2-11-1-初始" aria-hidden="true">#</a> 2.11.1 初始</h4><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623161104053.png" alt="image-20220623161104053" tabindex="0" loading="lazy"><figcaption>image-20220623161104053</figcaption></figure><h4 id="_2-11-2-参数详细说明" tabindex="-1"><a class="header-anchor" href="#_2-11-2-参数详细说明" aria-hidden="true">#</a> 2.11.2 参数详细说明</h4><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:left;">描述</th><th style="text-align:left;">是否必填</th></tr></thead><tbody><tr><td style="text-align:left;">Name</td><td style="text-align:left;">树中显示的此元件的描述性名称。</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Comments</td><td style="text-align:left;">注释</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Variable Name</td><td style="text-align:left;">变量名，存储随机字符串的变量的名称。</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Output Format</td><td style="text-align:left;">格式化字符串，要使用的java.text.DecimalFormat格式字符串。例如，“ 000”将生成至少3位数字，或者“ USER_000”将生成USER_nnn形式的输出。如果未指定，则默认为使用Long.toString（）生成数字。</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Minimum Value</td><td style="text-align:left;">最小值；生成的随机数的最小值（长整数）。</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Maximum Value</td><td style="text-align:left;">最大值；生成的随机数的最大值（长整数）。</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Seed for Random function</td><td style="text-align:left;">随机种子，随机数生成器的种子。默认值为当前时间，以毫秒为单位。如果在“将每个线程”设置为true的情况下使用相同的种子值，则与“ 随机” 类一样，您将为earch线程获得相同的值</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Per Thread(User)?</td><td style="text-align:left;">每个线程，如果为False，则在线程组中的所有线程之间共享生成器。如果为True，则每个线程都有自己的随机生成器。</td><td style="text-align:left;"></td></tr></tbody></table><h3 id="_2-12-user-defined-variables-重要" tabindex="-1"><a class="header-anchor" href="#_2-12-user-defined-variables-重要" aria-hidden="true">#</a> 2.12 User Defined Variables（重要）</h3><p>如果您有多个线程组，请确保对不同的值使用不同的名称，因为UDV在线程组之间共享。同样，这些变量在处理完元素之后才可用，因此您不能引用在同一元素中定义的变量。您可以引用在早期UDV或测试计划中定义的变量。</p><blockquote><p>UDV在线程组之间共享，根据这个特性，我们全局的东西就可以设在这</p></blockquote><h4 id="_2-12-1-初识" tabindex="-1"><a class="header-anchor" href="#_2-12-1-初识" aria-hidden="true">#</a> 2.12.1 初识</h4><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220623161309686.png" alt="image-20220623161309686" tabindex="0" loading="lazy"><figcaption>image-20220623161309686</figcaption></figure><h4 id="_2-12-2-参数详细说明" tabindex="-1"><a class="header-anchor" href="#_2-12-2-参数详细说明" aria-hidden="true">#</a> 2.12.2 参数详细说明</h4><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:left;">描述</th><th style="text-align:left;">是否必填</th></tr></thead><tbody><tr><td style="text-align:left;">Name</td><td style="text-align:left;">树中显示此元件描述的名称</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">Comments</td><td style="text-align:left;">注释</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">User Define Variables</td><td style="text-align:left;">用户定义的变量。变量名称/值对。您需要在$ {...}结构的方括号内放置“名称”（Name）列下的字符串，以便以后使用变量。然后，整个$ {...}将由“值”列中的字符串替换</td><td style="text-align:left;"></td></tr></tbody></table><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>',39),c={href:"https://cloud.tencent.com/developer/inventory/1923/article/1643120",target:"_blank",rel:"noopener noreferrer"};function x(y,u){const a=s("ExternalLinkIcon");return n(),r("div",null,[h,t("p",null,[e("这个元件可以设置HTTP请求控制器使用的默认值。例如，图中【服务器名称或IP】项目内填入了【"),t("a",o,[e("example.com"),l(a)]),e("】，后面的HTTP请求如果IP也是example.com的话，那么只要将【服务器名称或IP】留空，那么这个字段将自动继承HTTP请求默认值中的值。其他诸如【协议】、【端口号】、【路径】等同此。")]),f,t("p",null,[t("a",c,[e("Jmeter(八) - 从入门到精通 - JMeter配置元件"),l(a)])])])}const m=d(g,[["render",x],["__file","dev-y-pu-jmeter-config.html.vue"]]);export{m as default};
