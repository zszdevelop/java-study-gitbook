import{_ as l,W as i,X as e,a0 as n}from"./framework-0cf5f349.js";const o={},a=n('<h1 id="锁机制锁" tabindex="-1"><a class="header-anchor" href="#锁机制锁" aria-hidden="true">#</a> 锁机制锁</h1><h2 id="_1-myisam-和innodb-存储引擎使用的锁" tabindex="-1"><a class="header-anchor" href="#_1-myisam-和innodb-存储引擎使用的锁" aria-hidden="true">#</a> 1. MyISAM 和InnoDB 存储引擎使用的锁</h2><ul><li>MyISAM 采用的是表级锁（table-level locking）</li><li>InnoDB 支持行级锁（row-level locking）和表级锁，默认行为是行级锁</li></ul><h2 id="_2-表级锁和行级锁对比" tabindex="-1"><a class="header-anchor" href="#_2-表级锁和行级锁对比" aria-hidden="true">#</a> 2.表级锁和行级锁对比</h2><ul><li><p>表级锁</p><p>MySQL 中锁定 <strong>粒度最大</strong>的一种锁，对当前<strong>操作的整张表加锁</strong></p><ul><li>优势 <ul><li>实现简单，资源消耗少，加锁快</li><li>不会出现死锁</li></ul></li><li>缺点 <ul><li>其锁粒度最大，触发锁冲突的概率最高</li><li>并发度最低</li></ul></li></ul></li><li><p>行级锁</p><p>MySQL 中锁定 <strong>粒度最小</strong>的一种锁，只针对当前<strong>操作的行加锁</strong></p><ul><li>优势</li><li>大大减少数据库操作的冲突</li><li>加锁粒度小，并发度高</li><li>缺点 <ul><li>加锁的开销大</li><li>加锁慢</li><li>会出现死锁</li></ul></li></ul></li></ul><h2 id="_3-innodb存储引擎的锁算法" tabindex="-1"><a class="header-anchor" href="#_3-innodb存储引擎的锁算法" aria-hidden="true">#</a> 3. InnoDB存储引擎的锁算法</h2><ul><li>Record lock：单个行记录上的锁</li><li>Gap lock: 间隙锁，锁定一个范围，不包括记录本身</li><li><strong>Next-key lock: record+gap 锁定一个锁范围，包含记录本身</strong></li></ul><h3 id="_3-1-相关知识点" tabindex="-1"><a class="header-anchor" href="#_3-1-相关知识点" aria-hidden="true">#</a> 3.1 相关知识点</h3><ol><li>innodb 对于行的查询使用next-key lock</li><li>next-locking keying 为了解决Phantom Problem幻读问题</li><li>当查询的索引含有唯一属性时，将next-key lock降级为 record key</li><li>Gap 锁设计的目的是为了阻止多个事务将记录插入到同一范围内，这会导致幻读问题的产生</li><li>有两种方式显示关闭gap 锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） <ol><li>将事务隔离级别设置为READ-COMMITTED</li><li>将参数innodb_locks_unsafe_for_binlog 设置为1</li></ol></li></ol>',9),r=[a];function t(c,d){return i(),e("div",null,r)}const h=l(o,[["render",t],["__file","mysql-y-lock.html.vue"]]);export{h as default};
